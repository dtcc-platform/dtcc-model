// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dtcc.proto

#include "dtcc.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace DTCC {
constexpr Object_GeometryEntry_DoNotUse::Object_GeometryEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Object_GeometryEntry_DoNotUseDefaultTypeInternal {
  constexpr Object_GeometryEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Object_GeometryEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Object_GeometryEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Object_GeometryEntry_DoNotUseDefaultTypeInternal _Object_GeometryEntry_DoNotUse_default_instance_;
constexpr Object::Object(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : geometry_()
  , quantities_()
  , children_()
  , id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , attributes_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , _oneof_case_{}{}
struct ObjectDefaultTypeInternal {
  constexpr ObjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectDefaultTypeInternal() {}
  union {
    Object _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectDefaultTypeInternal _Object_default_instance_;
constexpr City::City(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CityDefaultTypeInternal {
  constexpr CityDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CityDefaultTypeInternal() {}
  union {
    City _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CityDefaultTypeInternal _City_default_instance_;
constexpr Building::Building(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BuildingDefaultTypeInternal {
  constexpr BuildingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BuildingDefaultTypeInternal() {}
  union {
    Building _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BuildingDefaultTypeInternal _Building_default_instance_;
constexpr Terrain::Terrain(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct TerrainDefaultTypeInternal {
  constexpr TerrainDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TerrainDefaultTypeInternal() {}
  union {
    Terrain _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TerrainDefaultTypeInternal _Terrain_default_instance_;
constexpr CityObject::CityObject(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CityObjectDefaultTypeInternal {
  constexpr CityObjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CityObjectDefaultTypeInternal() {}
  union {
    CityObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CityObjectDefaultTypeInternal _CityObject_default_instance_;
constexpr BuildingPart::BuildingPart(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BuildingPartDefaultTypeInternal {
  constexpr BuildingPartDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BuildingPartDefaultTypeInternal() {}
  union {
    BuildingPart _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BuildingPartDefaultTypeInternal _BuildingPart_default_instance_;
constexpr Bounds::Bounds(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : xmin_(0)
  , ymin_(0)
  , zmin_(0)
  , xmax_(0)
  , ymax_(0)
  , zmax_(0){}
struct BoundsDefaultTypeInternal {
  constexpr BoundsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BoundsDefaultTypeInternal() {}
  union {
    Bounds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BoundsDefaultTypeInternal _Bounds_default_instance_;
constexpr Transform::Transform(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : affine_()
  , srs_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct TransformDefaultTypeInternal {
  constexpr TransformDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TransformDefaultTypeInternal() {}
  union {
    Transform _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TransformDefaultTypeInternal _Transform_default_instance_;
constexpr LineString::LineString(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vertices_(){}
struct LineStringDefaultTypeInternal {
  constexpr LineStringDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LineStringDefaultTypeInternal() {}
  union {
    LineString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LineStringDefaultTypeInternal _LineString_default_instance_;
constexpr Geometry::Geometry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bounds_(nullptr)
  , transform_(nullptr)
  , _oneof_case_{}{}
struct GeometryDefaultTypeInternal {
  constexpr GeometryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GeometryDefaultTypeInternal() {}
  union {
    Geometry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GeometryDefaultTypeInternal _Geometry_default_instance_;
constexpr Surface::Surface(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vertices_()
  , normal_()
  , holes_(){}
struct SurfaceDefaultTypeInternal {
  constexpr SurfaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SurfaceDefaultTypeInternal() {}
  union {
    Surface _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SurfaceDefaultTypeInternal _Surface_default_instance_;
constexpr MultiSurface::MultiSurface(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : surfaces_(){}
struct MultiSurfaceDefaultTypeInternal {
  constexpr MultiSurfaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MultiSurfaceDefaultTypeInternal() {}
  union {
    MultiSurface _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MultiSurfaceDefaultTypeInternal _MultiSurface_default_instance_;
constexpr PointCloud::PointCloud(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : points_()
  , classification_()
  , _classification_cached_byte_size_(0)
  , intensity_()
  , _intensity_cached_byte_size_(0)
  , return_number_()
  , _return_number_cached_byte_size_(0)
  , num_returns_()
  , _num_returns_cached_byte_size_(0){}
struct PointCloudDefaultTypeInternal {
  constexpr PointCloudDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PointCloudDefaultTypeInternal() {}
  union {
    PointCloud _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PointCloudDefaultTypeInternal _PointCloud_default_instance_;
constexpr Mesh::Mesh(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vertices_()
  , faces_()
  , _faces_cached_byte_size_(0){}
struct MeshDefaultTypeInternal {
  constexpr MeshDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MeshDefaultTypeInternal() {}
  union {
    Mesh _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MeshDefaultTypeInternal _Mesh_default_instance_;
constexpr VolumeMesh::VolumeMesh(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vertices_()
  , cells_()
  , _cells_cached_byte_size_(0){}
struct VolumeMeshDefaultTypeInternal {
  constexpr VolumeMeshDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VolumeMeshDefaultTypeInternal() {}
  union {
    VolumeMesh _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VolumeMeshDefaultTypeInternal _VolumeMesh_default_instance_;
constexpr Grid::Grid(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : width_(0)
  , height_(0)
  , xstep_(0)
  , ystep_(0){}
struct GridDefaultTypeInternal {
  constexpr GridDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GridDefaultTypeInternal() {}
  union {
    Grid _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GridDefaultTypeInternal _Grid_default_instance_;
constexpr VolumeGrid::VolumeGrid(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : width_(0)
  , height_(0)
  , depth_(0)
  , xstep_(0)
  , ystep_(0)
  , zstep_(0){}
struct VolumeGridDefaultTypeInternal {
  constexpr VolumeGridDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VolumeGridDefaultTypeInternal() {}
  union {
    VolumeGrid _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VolumeGridDefaultTypeInternal _VolumeGrid_default_instance_;
constexpr Quantity::Quantity(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , unit_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , geometry_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , dim_(0){}
struct QuantityDefaultTypeInternal {
  constexpr QuantityDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~QuantityDefaultTypeInternal() {}
  union {
    Quantity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT QuantityDefaultTypeInternal _Quantity_default_instance_;
constexpr Raster::Raster(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , unit_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , grid_(nullptr)
  , dim_(0){}
struct RasterDefaultTypeInternal {
  constexpr RasterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RasterDefaultTypeInternal() {}
  union {
    Raster _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RasterDefaultTypeInternal _Raster_default_instance_;
}  // namespace DTCC
namespace DTCC {

// ===================================================================

Object_GeometryEntry_DoNotUse::Object_GeometryEntry_DoNotUse() {}
Object_GeometryEntry_DoNotUse::Object_GeometryEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Object_GeometryEntry_DoNotUse::MergeFrom(const Object_GeometryEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Object::_Internal {
 public:
  static const ::DTCC::City& city(const Object* msg);
  static const ::DTCC::Building& building(const Object* msg);
  static const ::DTCC::Terrain& terrain(const Object* msg);
  static const ::DTCC::CityObject& city_object(const Object* msg);
  static const ::DTCC::BuildingPart& building_part(const Object* msg);
};

const ::DTCC::City&
Object::_Internal::city(const Object* msg) {
  return *msg->type_.city_;
}
const ::DTCC::Building&
Object::_Internal::building(const Object* msg) {
  return *msg->type_.building_;
}
const ::DTCC::Terrain&
Object::_Internal::terrain(const Object* msg) {
  return *msg->type_.terrain_;
}
const ::DTCC::CityObject&
Object::_Internal::city_object(const Object* msg) {
  return *msg->type_.city_object_;
}
const ::DTCC::BuildingPart&
Object::_Internal::building_part(const Object* msg) {
  return *msg->type_.building_part_;
}
void Object::set_allocated_city(::DTCC::City* city) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (city) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::City>::GetOwningArena(city);
    if (message_arena != submessage_arena) {
      city = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, city, submessage_arena);
    }
    set_has_city();
    type_.city_ = city;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.city)
}
void Object::set_allocated_building(::DTCC::Building* building) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (building) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::Building>::GetOwningArena(building);
    if (message_arena != submessage_arena) {
      building = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, building, submessage_arena);
    }
    set_has_building();
    type_.building_ = building;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.building)
}
void Object::set_allocated_terrain(::DTCC::Terrain* terrain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (terrain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::Terrain>::GetOwningArena(terrain);
    if (message_arena != submessage_arena) {
      terrain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terrain, submessage_arena);
    }
    set_has_terrain();
    type_.terrain_ = terrain;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.terrain)
}
void Object::set_allocated_city_object(::DTCC::CityObject* city_object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (city_object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::CityObject>::GetOwningArena(city_object);
    if (message_arena != submessage_arena) {
      city_object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, city_object, submessage_arena);
    }
    set_has_city_object();
    type_.city_object_ = city_object;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.city_object)
}
void Object::set_allocated_building_part(::DTCC::BuildingPart* building_part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (building_part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::BuildingPart>::GetOwningArena(building_part);
    if (message_arena != submessage_arena) {
      building_part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, building_part, submessage_arena);
    }
    set_has_building_part();
    type_.building_part_ = building_part;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.building_part)
}
Object::Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  geometry_(arena),
  quantities_(arena),
  children_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Object)
}
Object::Object(const Object& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      quantities_(from.quantities_),
      children_(from.children_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  geometry_.MergeFrom(from.geometry_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_id().empty()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  attributes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_attributes().empty()) {
    attributes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attributes(), 
      GetArenaForAllocation());
  }
  clear_has_type();
  switch (from.type_case()) {
    case kCity: {
      _internal_mutable_city()->::DTCC::City::MergeFrom(from._internal_city());
      break;
    }
    case kBuilding: {
      _internal_mutable_building()->::DTCC::Building::MergeFrom(from._internal_building());
      break;
    }
    case kTerrain: {
      _internal_mutable_terrain()->::DTCC::Terrain::MergeFrom(from._internal_terrain());
      break;
    }
    case kCityObject: {
      _internal_mutable_city_object()->::DTCC::CityObject::MergeFrom(from._internal_city_object());
      break;
    }
    case kBuildingPart: {
      _internal_mutable_building_part()->::DTCC::BuildingPart::MergeFrom(from._internal_building_part());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:DTCC.Object)
}

inline void Object::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
attributes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
clear_has_type();
}

Object::~Object() {
  // @@protoc_insertion_point(destructor:DTCC.Object)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Object::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  attributes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_type()) {
    clear_type();
  }
}

void Object::ArenaDtor(void* object) {
  Object* _this = reinterpret_cast< Object* >(object);
  (void)_this;
}
void Object::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Object::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Object::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:DTCC.Object)
  switch (type_case()) {
    case kCity: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.city_;
      }
      break;
    }
    case kBuilding: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.building_;
      }
      break;
    }
    case kTerrain: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.terrain_;
      }
      break;
    }
    case kCityObject: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.city_object_;
      }
      break;
    }
    case kBuildingPart: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.building_part_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void Object::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Object)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  geometry_.Clear();
  quantities_.Clear();
  children_.Clear();
  id_.ClearToEmpty();
  attributes_.ClearToEmpty();
  clear_type();
  _internal_metadata_.Clear<std::string>();
}

const char* Object::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string attributes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_attributes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // map<string, .DTCC.Geometry> geometry = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&geometry_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .DTCC.Quantity quantities = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_quantities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .DTCC.Object children = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // .DTCC.City city = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_city(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.Building building = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_building(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.Terrain terrain = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_terrain(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.CityObject city_object = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_city_object(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.BuildingPart building_part = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_building_part(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Object::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Object)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Object.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string attributes = 2;
  if (!this->_internal_attributes().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_attributes().data(), static_cast<int>(this->_internal_attributes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Object.attributes");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_attributes(), target);
  }

  // map<string, .DTCC.Geometry> geometry = 3;
  if (!this->_internal_geometry().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "DTCC.Object.GeometryEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_geometry().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_geometry().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >::const_iterator
          it = this->_internal_geometry().begin();
          it != this->_internal_geometry().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Object_GeometryEntry_DoNotUse::Funcs::InternalSerialize(3, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >::const_iterator
          it = this->_internal_geometry().begin();
          it != this->_internal_geometry().end(); ++it) {
        target = Object_GeometryEntry_DoNotUse::Funcs::InternalSerialize(3, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // repeated .DTCC.Quantity quantities = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_quantities_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_quantities(i), target, stream);
  }

  // repeated .DTCC.Object children = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_children_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_children(i), target, stream);
  }

  // .DTCC.City city = 6;
  if (_internal_has_city()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::city(this), target, stream);
  }

  // .DTCC.Building building = 7;
  if (_internal_has_building()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::building(this), target, stream);
  }

  // .DTCC.Terrain terrain = 8;
  if (_internal_has_terrain()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::terrain(this), target, stream);
  }

  // .DTCC.CityObject city_object = 9;
  if (_internal_has_city_object()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::city_object(this), target, stream);
  }

  // .DTCC.BuildingPart building_part = 10;
  if (_internal_has_building_part()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::building_part(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Object)
  return target;
}

size_t Object::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Object)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .DTCC.Geometry> geometry = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_geometry_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >::const_iterator
      it = this->_internal_geometry().begin();
      it != this->_internal_geometry().end(); ++it) {
    total_size += Object_GeometryEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .DTCC.Quantity quantities = 4;
  total_size += 1UL * this->_internal_quantities_size();
  for (const auto& msg : this->quantities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .DTCC.Object children = 5;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string attributes = 2;
  if (!this->_internal_attributes().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_attributes());
  }

  switch (type_case()) {
    // .DTCC.City city = 6;
    case kCity: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.city_);
      break;
    }
    // .DTCC.Building building = 7;
    case kBuilding: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.building_);
      break;
    }
    // .DTCC.Terrain terrain = 8;
    case kTerrain: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.terrain_);
      break;
    }
    // .DTCC.CityObject city_object = 9;
    case kCityObject: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.city_object_);
      break;
    }
    // .DTCC.BuildingPart building_part = 10;
    case kBuildingPart: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.building_part_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Object::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Object*>(
      &from));
}

void Object::MergeFrom(const Object& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Object)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  geometry_.MergeFrom(from.geometry_);
  quantities_.MergeFrom(from.quantities_);
  children_.MergeFrom(from.children_);
  if (!from._internal_id().empty()) {
    _internal_set_id(from._internal_id());
  }
  if (!from._internal_attributes().empty()) {
    _internal_set_attributes(from._internal_attributes());
  }
  switch (from.type_case()) {
    case kCity: {
      _internal_mutable_city()->::DTCC::City::MergeFrom(from._internal_city());
      break;
    }
    case kBuilding: {
      _internal_mutable_building()->::DTCC::Building::MergeFrom(from._internal_building());
      break;
    }
    case kTerrain: {
      _internal_mutable_terrain()->::DTCC::Terrain::MergeFrom(from._internal_terrain());
      break;
    }
    case kCityObject: {
      _internal_mutable_city_object()->::DTCC::CityObject::MergeFrom(from._internal_city_object());
      break;
    }
    case kBuildingPart: {
      _internal_mutable_building_part()->::DTCC::BuildingPart::MergeFrom(from._internal_building_part());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Object::CopyFrom(const Object& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Object)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Object::IsInitialized() const {
  return true;
}

void Object::InternalSwap(Object* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  geometry_.InternalSwap(&other->geometry_);
  quantities_.InternalSwap(&other->quantities_);
  children_.InternalSwap(&other->children_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, GetArenaForAllocation(),
      &other->id_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attributes_, GetArenaForAllocation(),
      &other->attributes_, other->GetArenaForAllocation()
  );
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Object::GetTypeName() const {
  return "DTCC.Object";
}


// ===================================================================

class City::_Internal {
 public:
};

City::City(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.City)
}
City::City(const City& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.City)
}

inline void City::SharedCtor() {
}

City::~City() {
  // @@protoc_insertion_point(destructor:DTCC.City)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void City::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void City::ArenaDtor(void* object) {
  City* _this = reinterpret_cast< City* >(object);
  (void)_this;
}
void City::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void City::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void City::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.City)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* City::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* City::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.City)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.City)
  return target;
}

size_t City::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.City)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void City::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const City*>(
      &from));
}

void City::MergeFrom(const City& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.City)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void City::CopyFrom(const City& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.City)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool City::IsInitialized() const {
  return true;
}

void City::InternalSwap(City* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string City::GetTypeName() const {
  return "DTCC.City";
}


// ===================================================================

class Building::_Internal {
 public:
};

Building::Building(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Building)
}
Building::Building(const Building& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.Building)
}

inline void Building::SharedCtor() {
}

Building::~Building() {
  // @@protoc_insertion_point(destructor:DTCC.Building)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Building::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Building::ArenaDtor(void* object) {
  Building* _this = reinterpret_cast< Building* >(object);
  (void)_this;
}
void Building::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Building::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Building::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Building)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Building::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Building::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Building)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Building)
  return target;
}

size_t Building::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Building)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Building::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Building*>(
      &from));
}

void Building::MergeFrom(const Building& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Building)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Building::CopyFrom(const Building& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Building)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Building::IsInitialized() const {
  return true;
}

void Building::InternalSwap(Building* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Building::GetTypeName() const {
  return "DTCC.Building";
}


// ===================================================================

class Terrain::_Internal {
 public:
};

Terrain::Terrain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Terrain)
}
Terrain::Terrain(const Terrain& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.Terrain)
}

inline void Terrain::SharedCtor() {
}

Terrain::~Terrain() {
  // @@protoc_insertion_point(destructor:DTCC.Terrain)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Terrain::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Terrain::ArenaDtor(void* object) {
  Terrain* _this = reinterpret_cast< Terrain* >(object);
  (void)_this;
}
void Terrain::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Terrain::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Terrain::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Terrain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Terrain::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Terrain::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Terrain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Terrain)
  return target;
}

size_t Terrain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Terrain)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Terrain::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Terrain*>(
      &from));
}

void Terrain::MergeFrom(const Terrain& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Terrain)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Terrain::CopyFrom(const Terrain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Terrain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Terrain::IsInitialized() const {
  return true;
}

void Terrain::InternalSwap(Terrain* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Terrain::GetTypeName() const {
  return "DTCC.Terrain";
}


// ===================================================================

class CityObject::_Internal {
 public:
};

CityObject::CityObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.CityObject)
}
CityObject::CityObject(const CityObject& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.CityObject)
}

inline void CityObject::SharedCtor() {
}

CityObject::~CityObject() {
  // @@protoc_insertion_point(destructor:DTCC.CityObject)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CityObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CityObject::ArenaDtor(void* object) {
  CityObject* _this = reinterpret_cast< CityObject* >(object);
  (void)_this;
}
void CityObject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CityObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CityObject::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.CityObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CityObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CityObject::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.CityObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.CityObject)
  return target;
}

size_t CityObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.CityObject)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CityObject::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CityObject*>(
      &from));
}

void CityObject::MergeFrom(const CityObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.CityObject)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CityObject::CopyFrom(const CityObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.CityObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CityObject::IsInitialized() const {
  return true;
}

void CityObject::InternalSwap(CityObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CityObject::GetTypeName() const {
  return "DTCC.CityObject";
}


// ===================================================================

class BuildingPart::_Internal {
 public:
};

BuildingPart::BuildingPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.BuildingPart)
}
BuildingPart::BuildingPart(const BuildingPart& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.BuildingPart)
}

inline void BuildingPart::SharedCtor() {
}

BuildingPart::~BuildingPart() {
  // @@protoc_insertion_point(destructor:DTCC.BuildingPart)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BuildingPart::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BuildingPart::ArenaDtor(void* object) {
  BuildingPart* _this = reinterpret_cast< BuildingPart* >(object);
  (void)_this;
}
void BuildingPart::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BuildingPart::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BuildingPart::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.BuildingPart)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* BuildingPart::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BuildingPart::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.BuildingPart)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.BuildingPart)
  return target;
}

size_t BuildingPart::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.BuildingPart)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BuildingPart::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BuildingPart*>(
      &from));
}

void BuildingPart::MergeFrom(const BuildingPart& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.BuildingPart)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BuildingPart::CopyFrom(const BuildingPart& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.BuildingPart)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildingPart::IsInitialized() const {
  return true;
}

void BuildingPart::InternalSwap(BuildingPart* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string BuildingPart::GetTypeName() const {
  return "DTCC.BuildingPart";
}


// ===================================================================

class Bounds::_Internal {
 public:
};

Bounds::Bounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Bounds)
}
Bounds::Bounds(const Bounds& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&xmin_, &from.xmin_,
    static_cast<size_t>(reinterpret_cast<char*>(&zmax_) -
    reinterpret_cast<char*>(&xmin_)) + sizeof(zmax_));
  // @@protoc_insertion_point(copy_constructor:DTCC.Bounds)
}

inline void Bounds::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&xmin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&zmax_) -
    reinterpret_cast<char*>(&xmin_)) + sizeof(zmax_));
}

Bounds::~Bounds() {
  // @@protoc_insertion_point(destructor:DTCC.Bounds)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Bounds::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Bounds::ArenaDtor(void* object) {
  Bounds* _this = reinterpret_cast< Bounds* >(object);
  (void)_this;
}
void Bounds::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Bounds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Bounds::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Bounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&xmin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&zmax_) -
      reinterpret_cast<char*>(&xmin_)) + sizeof(zmax_));
  _internal_metadata_.Clear<std::string>();
}

const char* Bounds::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float xmin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          xmin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float ymin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          ymin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float zmin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          zmin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float xmax = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          xmax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float ymax = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          ymax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float zmax = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          zmax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Bounds::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Bounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float xmin = 1;
  if (!(this->_internal_xmin() <= 0 && this->_internal_xmin() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_xmin(), target);
  }

  // float ymin = 2;
  if (!(this->_internal_ymin() <= 0 && this->_internal_ymin() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_ymin(), target);
  }

  // float zmin = 3;
  if (!(this->_internal_zmin() <= 0 && this->_internal_zmin() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_zmin(), target);
  }

  // float xmax = 4;
  if (!(this->_internal_xmax() <= 0 && this->_internal_xmax() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_xmax(), target);
  }

  // float ymax = 5;
  if (!(this->_internal_ymax() <= 0 && this->_internal_ymax() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_ymax(), target);
  }

  // float zmax = 6;
  if (!(this->_internal_zmax() <= 0 && this->_internal_zmax() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_zmax(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Bounds)
  return target;
}

size_t Bounds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Bounds)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float xmin = 1;
  if (!(this->_internal_xmin() <= 0 && this->_internal_xmin() >= 0)) {
    total_size += 1 + 4;
  }

  // float ymin = 2;
  if (!(this->_internal_ymin() <= 0 && this->_internal_ymin() >= 0)) {
    total_size += 1 + 4;
  }

  // float zmin = 3;
  if (!(this->_internal_zmin() <= 0 && this->_internal_zmin() >= 0)) {
    total_size += 1 + 4;
  }

  // float xmax = 4;
  if (!(this->_internal_xmax() <= 0 && this->_internal_xmax() >= 0)) {
    total_size += 1 + 4;
  }

  // float ymax = 5;
  if (!(this->_internal_ymax() <= 0 && this->_internal_ymax() >= 0)) {
    total_size += 1 + 4;
  }

  // float zmax = 6;
  if (!(this->_internal_zmax() <= 0 && this->_internal_zmax() >= 0)) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Bounds::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Bounds*>(
      &from));
}

void Bounds::MergeFrom(const Bounds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Bounds)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from._internal_xmin() <= 0 && from._internal_xmin() >= 0)) {
    _internal_set_xmin(from._internal_xmin());
  }
  if (!(from._internal_ymin() <= 0 && from._internal_ymin() >= 0)) {
    _internal_set_ymin(from._internal_ymin());
  }
  if (!(from._internal_zmin() <= 0 && from._internal_zmin() >= 0)) {
    _internal_set_zmin(from._internal_zmin());
  }
  if (!(from._internal_xmax() <= 0 && from._internal_xmax() >= 0)) {
    _internal_set_xmax(from._internal_xmax());
  }
  if (!(from._internal_ymax() <= 0 && from._internal_ymax() >= 0)) {
    _internal_set_ymax(from._internal_ymax());
  }
  if (!(from._internal_zmax() <= 0 && from._internal_zmax() >= 0)) {
    _internal_set_zmax(from._internal_zmax());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Bounds::CopyFrom(const Bounds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Bounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bounds::IsInitialized() const {
  return true;
}

void Bounds::InternalSwap(Bounds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Bounds, zmax_)
      + sizeof(Bounds::zmax_)
      - PROTOBUF_FIELD_OFFSET(Bounds, xmin_)>(
          reinterpret_cast<char*>(&xmin_),
          reinterpret_cast<char*>(&other->xmin_));
}

std::string Bounds::GetTypeName() const {
  return "DTCC.Bounds";
}


// ===================================================================

class Transform::_Internal {
 public:
};

Transform::Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  affine_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Transform)
}
Transform::Transform(const Transform& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      affine_(from.affine_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  srs_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_srs().empty()) {
    srs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_srs(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:DTCC.Transform)
}

inline void Transform::SharedCtor() {
srs_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Transform::~Transform() {
  // @@protoc_insertion_point(destructor:DTCC.Transform)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Transform::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  srs_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Transform::ArenaDtor(void* object) {
  Transform* _this = reinterpret_cast< Transform* >(object);
  (void)_this;
}
void Transform::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Transform::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Transform::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Transform)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  affine_.Clear();
  srs_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Transform::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string srs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_srs();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float affine = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_affine(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21) {
          _internal_add_affine(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Transform::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Transform)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string srs = 1;
  if (!this->_internal_srs().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_srs().data(), static_cast<int>(this->_internal_srs().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Transform.srs");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_srs(), target);
  }

  // repeated float affine = 2;
  if (this->_internal_affine_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_affine(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Transform)
  return target;
}

size_t Transform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Transform)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float affine = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_affine_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  // string srs = 1;
  if (!this->_internal_srs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_srs());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Transform::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Transform*>(
      &from));
}

void Transform::MergeFrom(const Transform& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Transform)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  affine_.MergeFrom(from.affine_);
  if (!from._internal_srs().empty()) {
    _internal_set_srs(from._internal_srs());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Transform::CopyFrom(const Transform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Transform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transform::IsInitialized() const {
  return true;
}

void Transform::InternalSwap(Transform* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  affine_.InternalSwap(&other->affine_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &srs_, GetArenaForAllocation(),
      &other->srs_, other->GetArenaForAllocation()
  );
}

std::string Transform::GetTypeName() const {
  return "DTCC.Transform";
}


// ===================================================================

class LineString::_Internal {
 public:
};

LineString::LineString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vertices_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.LineString)
}
LineString::LineString(const LineString& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vertices_(from.vertices_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.LineString)
}

inline void LineString::SharedCtor() {
}

LineString::~LineString() {
  // @@protoc_insertion_point(destructor:DTCC.LineString)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LineString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LineString::ArenaDtor(void* object) {
  LineString* _this = reinterpret_cast< LineString* >(object);
  (void)_this;
}
void LineString::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LineString::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LineString::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.LineString)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vertices_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LineString::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float vertices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_vertices(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13) {
          _internal_add_vertices(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LineString::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.LineString)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float vertices = 1;
  if (this->_internal_vertices_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_vertices(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.LineString)
  return target;
}

size_t LineString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.LineString)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float vertices = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_vertices_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LineString::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LineString*>(
      &from));
}

void LineString::MergeFrom(const LineString& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.LineString)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vertices_.MergeFrom(from.vertices_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LineString::CopyFrom(const LineString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.LineString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LineString::IsInitialized() const {
  return true;
}

void LineString::InternalSwap(LineString* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vertices_.InternalSwap(&other->vertices_);
}

std::string LineString::GetTypeName() const {
  return "DTCC.LineString";
}


// ===================================================================

class Geometry::_Internal {
 public:
  static const ::DTCC::Bounds& bounds(const Geometry* msg);
  static const ::DTCC::Transform& transform(const Geometry* msg);
  static const ::DTCC::Surface& surface(const Geometry* msg);
  static const ::DTCC::MultiSurface& multi_surface(const Geometry* msg);
  static const ::DTCC::PointCloud& point_cloud(const Geometry* msg);
  static const ::DTCC::Mesh& mesh(const Geometry* msg);
  static const ::DTCC::VolumeMesh& volume_mesh(const Geometry* msg);
  static const ::DTCC::Grid& grid(const Geometry* msg);
  static const ::DTCC::VolumeGrid& volume_grid(const Geometry* msg);
};

const ::DTCC::Bounds&
Geometry::_Internal::bounds(const Geometry* msg) {
  return *msg->bounds_;
}
const ::DTCC::Transform&
Geometry::_Internal::transform(const Geometry* msg) {
  return *msg->transform_;
}
const ::DTCC::Surface&
Geometry::_Internal::surface(const Geometry* msg) {
  return *msg->type_.surface_;
}
const ::DTCC::MultiSurface&
Geometry::_Internal::multi_surface(const Geometry* msg) {
  return *msg->type_.multi_surface_;
}
const ::DTCC::PointCloud&
Geometry::_Internal::point_cloud(const Geometry* msg) {
  return *msg->type_.point_cloud_;
}
const ::DTCC::Mesh&
Geometry::_Internal::mesh(const Geometry* msg) {
  return *msg->type_.mesh_;
}
const ::DTCC::VolumeMesh&
Geometry::_Internal::volume_mesh(const Geometry* msg) {
  return *msg->type_.volume_mesh_;
}
const ::DTCC::Grid&
Geometry::_Internal::grid(const Geometry* msg) {
  return *msg->type_.grid_;
}
const ::DTCC::VolumeGrid&
Geometry::_Internal::volume_grid(const Geometry* msg) {
  return *msg->type_.volume_grid_;
}
void Geometry::set_allocated_surface(::DTCC::Surface* surface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (surface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::Surface>::GetOwningArena(surface);
    if (message_arena != submessage_arena) {
      surface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, surface, submessage_arena);
    }
    set_has_surface();
    type_.surface_ = surface;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.surface)
}
void Geometry::set_allocated_multi_surface(::DTCC::MultiSurface* multi_surface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (multi_surface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::MultiSurface>::GetOwningArena(multi_surface);
    if (message_arena != submessage_arena) {
      multi_surface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multi_surface, submessage_arena);
    }
    set_has_multi_surface();
    type_.multi_surface_ = multi_surface;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.multi_surface)
}
void Geometry::set_allocated_point_cloud(::DTCC::PointCloud* point_cloud) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (point_cloud) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::PointCloud>::GetOwningArena(point_cloud);
    if (message_arena != submessage_arena) {
      point_cloud = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_cloud, submessage_arena);
    }
    set_has_point_cloud();
    type_.point_cloud_ = point_cloud;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.point_cloud)
}
void Geometry::set_allocated_mesh(::DTCC::Mesh* mesh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (mesh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::Mesh>::GetOwningArena(mesh);
    if (message_arena != submessage_arena) {
      mesh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mesh, submessage_arena);
    }
    set_has_mesh();
    type_.mesh_ = mesh;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.mesh)
}
void Geometry::set_allocated_volume_mesh(::DTCC::VolumeMesh* volume_mesh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (volume_mesh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::VolumeMesh>::GetOwningArena(volume_mesh);
    if (message_arena != submessage_arena) {
      volume_mesh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_mesh, submessage_arena);
    }
    set_has_volume_mesh();
    type_.volume_mesh_ = volume_mesh;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.volume_mesh)
}
void Geometry::set_allocated_grid(::DTCC::Grid* grid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (grid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::Grid>::GetOwningArena(grid);
    if (message_arena != submessage_arena) {
      grid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grid, submessage_arena);
    }
    set_has_grid();
    type_.grid_ = grid;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.grid)
}
void Geometry::set_allocated_volume_grid(::DTCC::VolumeGrid* volume_grid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (volume_grid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::VolumeGrid>::GetOwningArena(volume_grid);
    if (message_arena != submessage_arena) {
      volume_grid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_grid, submessage_arena);
    }
    set_has_volume_grid();
    type_.volume_grid_ = volume_grid;
  }
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.volume_grid)
}
Geometry::Geometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Geometry)
}
Geometry::Geometry(const Geometry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_bounds()) {
    bounds_ = new ::DTCC::Bounds(*from.bounds_);
  } else {
    bounds_ = nullptr;
  }
  if (from._internal_has_transform()) {
    transform_ = new ::DTCC::Transform(*from.transform_);
  } else {
    transform_ = nullptr;
  }
  clear_has_type();
  switch (from.type_case()) {
    case kSurface: {
      _internal_mutable_surface()->::DTCC::Surface::MergeFrom(from._internal_surface());
      break;
    }
    case kMultiSurface: {
      _internal_mutable_multi_surface()->::DTCC::MultiSurface::MergeFrom(from._internal_multi_surface());
      break;
    }
    case kPointCloud: {
      _internal_mutable_point_cloud()->::DTCC::PointCloud::MergeFrom(from._internal_point_cloud());
      break;
    }
    case kMesh: {
      _internal_mutable_mesh()->::DTCC::Mesh::MergeFrom(from._internal_mesh());
      break;
    }
    case kVolumeMesh: {
      _internal_mutable_volume_mesh()->::DTCC::VolumeMesh::MergeFrom(from._internal_volume_mesh());
      break;
    }
    case kGrid: {
      _internal_mutable_grid()->::DTCC::Grid::MergeFrom(from._internal_grid());
      break;
    }
    case kVolumeGrid: {
      _internal_mutable_volume_grid()->::DTCC::VolumeGrid::MergeFrom(from._internal_volume_grid());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:DTCC.Geometry)
}

inline void Geometry::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bounds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&transform_) -
    reinterpret_cast<char*>(&bounds_)) + sizeof(transform_));
clear_has_type();
}

Geometry::~Geometry() {
  // @@protoc_insertion_point(destructor:DTCC.Geometry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Geometry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete bounds_;
  if (this != internal_default_instance()) delete transform_;
  if (has_type()) {
    clear_type();
  }
}

void Geometry::ArenaDtor(void* object) {
  Geometry* _this = reinterpret_cast< Geometry* >(object);
  (void)_this;
}
void Geometry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Geometry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Geometry::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:DTCC.Geometry)
  switch (type_case()) {
    case kSurface: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.surface_;
      }
      break;
    }
    case kMultiSurface: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.multi_surface_;
      }
      break;
    }
    case kPointCloud: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.point_cloud_;
      }
      break;
    }
    case kMesh: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.mesh_;
      }
      break;
    }
    case kVolumeMesh: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.volume_mesh_;
      }
      break;
    }
    case kGrid: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.grid_;
      }
      break;
    }
    case kVolumeGrid: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.volume_grid_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void Geometry::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Geometry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && bounds_ != nullptr) {
    delete bounds_;
  }
  bounds_ = nullptr;
  if (GetArenaForAllocation() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
  clear_type();
  _internal_metadata_.Clear<std::string>();
}

const char* Geometry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .DTCC.Bounds bounds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_bounds(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.Transform transform = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transform(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.Surface surface = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_surface(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.MultiSurface multi_surface = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_multi_surface(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.PointCloud point_cloud = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_cloud(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.Mesh mesh = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_mesh(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.VolumeMesh volume_mesh = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_volume_mesh(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.Grid grid = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_grid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.VolumeGrid volume_grid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_volume_grid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Geometry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Geometry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .DTCC.Bounds bounds = 1;
  if (this->_internal_has_bounds()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::bounds(this), target, stream);
  }

  // .DTCC.Transform transform = 2;
  if (this->_internal_has_transform()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::transform(this), target, stream);
  }

  // .DTCC.Surface surface = 3;
  if (_internal_has_surface()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::surface(this), target, stream);
  }

  // .DTCC.MultiSurface multi_surface = 4;
  if (_internal_has_multi_surface()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::multi_surface(this), target, stream);
  }

  // .DTCC.PointCloud point_cloud = 5;
  if (_internal_has_point_cloud()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::point_cloud(this), target, stream);
  }

  // .DTCC.Mesh mesh = 6;
  if (_internal_has_mesh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::mesh(this), target, stream);
  }

  // .DTCC.VolumeMesh volume_mesh = 7;
  if (_internal_has_volume_mesh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::volume_mesh(this), target, stream);
  }

  // .DTCC.Grid grid = 8;
  if (_internal_has_grid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::grid(this), target, stream);
  }

  // .DTCC.VolumeGrid volume_grid = 9;
  if (_internal_has_volume_grid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::volume_grid(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Geometry)
  return target;
}

size_t Geometry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Geometry)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .DTCC.Bounds bounds = 1;
  if (this->_internal_has_bounds()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bounds_);
  }

  // .DTCC.Transform transform = 2;
  if (this->_internal_has_transform()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *transform_);
  }

  switch (type_case()) {
    // .DTCC.Surface surface = 3;
    case kSurface: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.surface_);
      break;
    }
    // .DTCC.MultiSurface multi_surface = 4;
    case kMultiSurface: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.multi_surface_);
      break;
    }
    // .DTCC.PointCloud point_cloud = 5;
    case kPointCloud: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.point_cloud_);
      break;
    }
    // .DTCC.Mesh mesh = 6;
    case kMesh: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.mesh_);
      break;
    }
    // .DTCC.VolumeMesh volume_mesh = 7;
    case kVolumeMesh: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.volume_mesh_);
      break;
    }
    // .DTCC.Grid grid = 8;
    case kGrid: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.grid_);
      break;
    }
    // .DTCC.VolumeGrid volume_grid = 9;
    case kVolumeGrid: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.volume_grid_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Geometry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Geometry*>(
      &from));
}

void Geometry::MergeFrom(const Geometry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Geometry)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_bounds()) {
    _internal_mutable_bounds()->::DTCC::Bounds::MergeFrom(from._internal_bounds());
  }
  if (from._internal_has_transform()) {
    _internal_mutable_transform()->::DTCC::Transform::MergeFrom(from._internal_transform());
  }
  switch (from.type_case()) {
    case kSurface: {
      _internal_mutable_surface()->::DTCC::Surface::MergeFrom(from._internal_surface());
      break;
    }
    case kMultiSurface: {
      _internal_mutable_multi_surface()->::DTCC::MultiSurface::MergeFrom(from._internal_multi_surface());
      break;
    }
    case kPointCloud: {
      _internal_mutable_point_cloud()->::DTCC::PointCloud::MergeFrom(from._internal_point_cloud());
      break;
    }
    case kMesh: {
      _internal_mutable_mesh()->::DTCC::Mesh::MergeFrom(from._internal_mesh());
      break;
    }
    case kVolumeMesh: {
      _internal_mutable_volume_mesh()->::DTCC::VolumeMesh::MergeFrom(from._internal_volume_mesh());
      break;
    }
    case kGrid: {
      _internal_mutable_grid()->::DTCC::Grid::MergeFrom(from._internal_grid());
      break;
    }
    case kVolumeGrid: {
      _internal_mutable_volume_grid()->::DTCC::VolumeGrid::MergeFrom(from._internal_volume_grid());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Geometry::CopyFrom(const Geometry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Geometry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Geometry::IsInitialized() const {
  return true;
}

void Geometry::InternalSwap(Geometry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Geometry, transform_)
      + sizeof(Geometry::transform_)
      - PROTOBUF_FIELD_OFFSET(Geometry, bounds_)>(
          reinterpret_cast<char*>(&bounds_),
          reinterpret_cast<char*>(&other->bounds_));
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Geometry::GetTypeName() const {
  return "DTCC.Geometry";
}


// ===================================================================

class Surface::_Internal {
 public:
};

Surface::Surface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vertices_(arena),
  normal_(arena),
  holes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Surface)
}
Surface::Surface(const Surface& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vertices_(from.vertices_),
      normal_(from.normal_),
      holes_(from.holes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.Surface)
}

inline void Surface::SharedCtor() {
}

Surface::~Surface() {
  // @@protoc_insertion_point(destructor:DTCC.Surface)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Surface::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Surface::ArenaDtor(void* object) {
  Surface* _this = reinterpret_cast< Surface* >(object);
  (void)_this;
}
void Surface::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Surface::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Surface::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Surface)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vertices_.Clear();
  normal_.Clear();
  holes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Surface::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float vertices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_vertices(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13) {
          _internal_add_vertices(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated float normal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_normal(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21) {
          _internal_add_normal(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated .DTCC.LineString holes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_holes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Surface::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Surface)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float vertices = 1;
  if (this->_internal_vertices_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_vertices(), target);
  }

  // repeated float normal = 2;
  if (this->_internal_normal_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_normal(), target);
  }

  // repeated .DTCC.LineString holes = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_holes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_holes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Surface)
  return target;
}

size_t Surface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Surface)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float vertices = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_vertices_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  // repeated float normal = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_normal_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  // repeated .DTCC.LineString holes = 3;
  total_size += 1UL * this->_internal_holes_size();
  for (const auto& msg : this->holes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Surface::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Surface*>(
      &from));
}

void Surface::MergeFrom(const Surface& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Surface)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vertices_.MergeFrom(from.vertices_);
  normal_.MergeFrom(from.normal_);
  holes_.MergeFrom(from.holes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Surface::CopyFrom(const Surface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Surface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Surface::IsInitialized() const {
  return true;
}

void Surface::InternalSwap(Surface* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vertices_.InternalSwap(&other->vertices_);
  normal_.InternalSwap(&other->normal_);
  holes_.InternalSwap(&other->holes_);
}

std::string Surface::GetTypeName() const {
  return "DTCC.Surface";
}


// ===================================================================

class MultiSurface::_Internal {
 public:
};

MultiSurface::MultiSurface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  surfaces_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.MultiSurface)
}
MultiSurface::MultiSurface(const MultiSurface& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      surfaces_(from.surfaces_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.MultiSurface)
}

inline void MultiSurface::SharedCtor() {
}

MultiSurface::~MultiSurface() {
  // @@protoc_insertion_point(destructor:DTCC.MultiSurface)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MultiSurface::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MultiSurface::ArenaDtor(void* object) {
  MultiSurface* _this = reinterpret_cast< MultiSurface* >(object);
  (void)_this;
}
void MultiSurface::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MultiSurface::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MultiSurface::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.MultiSurface)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  surfaces_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MultiSurface::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .DTCC.Surface surfaces = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_surfaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MultiSurface::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.MultiSurface)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .DTCC.Surface surfaces = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_surfaces_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_surfaces(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.MultiSurface)
  return target;
}

size_t MultiSurface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.MultiSurface)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .DTCC.Surface surfaces = 1;
  total_size += 1UL * this->_internal_surfaces_size();
  for (const auto& msg : this->surfaces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MultiSurface::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MultiSurface*>(
      &from));
}

void MultiSurface::MergeFrom(const MultiSurface& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.MultiSurface)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  surfaces_.MergeFrom(from.surfaces_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MultiSurface::CopyFrom(const MultiSurface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.MultiSurface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiSurface::IsInitialized() const {
  return true;
}

void MultiSurface::InternalSwap(MultiSurface* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  surfaces_.InternalSwap(&other->surfaces_);
}

std::string MultiSurface::GetTypeName() const {
  return "DTCC.MultiSurface";
}


// ===================================================================

class PointCloud::_Internal {
 public:
};

PointCloud::PointCloud(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  points_(arena),
  classification_(arena),
  intensity_(arena),
  return_number_(arena),
  num_returns_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.PointCloud)
}
PointCloud::PointCloud(const PointCloud& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      points_(from.points_),
      classification_(from.classification_),
      intensity_(from.intensity_),
      return_number_(from.return_number_),
      num_returns_(from.num_returns_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.PointCloud)
}

inline void PointCloud::SharedCtor() {
}

PointCloud::~PointCloud() {
  // @@protoc_insertion_point(destructor:DTCC.PointCloud)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PointCloud::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PointCloud::ArenaDtor(void* object) {
  PointCloud* _this = reinterpret_cast< PointCloud* >(object);
  (void)_this;
}
void PointCloud::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PointCloud::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PointCloud::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.PointCloud)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  classification_.Clear();
  intensity_.Clear();
  return_number_.Clear();
  num_returns_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PointCloud::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float points = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_points(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13) {
          _internal_add_points(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated uint32 classification = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_classification(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          _internal_add_classification(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 intensity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_intensity(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24) {
          _internal_add_intensity(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 return_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_return_number(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32) {
          _internal_add_return_number(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 num_returns = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_num_returns(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40) {
          _internal_add_num_returns(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PointCloud::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.PointCloud)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  // repeated uint32 classification = 2;
  {
    int byte_size = _classification_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_classification(), byte_size, target);
    }
  }

  // repeated uint32 intensity = 3;
  {
    int byte_size = _intensity_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_intensity(), byte_size, target);
    }
  }

  // repeated uint32 return_number = 4;
  {
    int byte_size = _return_number_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          4, _internal_return_number(), byte_size, target);
    }
  }

  // repeated uint32 num_returns = 5;
  {
    int byte_size = _num_returns_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          5, _internal_num_returns(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.PointCloud)
  return target;
}

size_t PointCloud::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.PointCloud)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float points = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_points_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  // repeated uint32 classification = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->classification_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _classification_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 intensity = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->intensity_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _intensity_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 return_number = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->return_number_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _return_number_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 num_returns = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->num_returns_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _num_returns_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PointCloud::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PointCloud*>(
      &from));
}

void PointCloud::MergeFrom(const PointCloud& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.PointCloud)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
  classification_.MergeFrom(from.classification_);
  intensity_.MergeFrom(from.intensity_);
  return_number_.MergeFrom(from.return_number_);
  num_returns_.MergeFrom(from.num_returns_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PointCloud::CopyFrom(const PointCloud& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.PointCloud)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointCloud::IsInitialized() const {
  return true;
}

void PointCloud::InternalSwap(PointCloud* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  points_.InternalSwap(&other->points_);
  classification_.InternalSwap(&other->classification_);
  intensity_.InternalSwap(&other->intensity_);
  return_number_.InternalSwap(&other->return_number_);
  num_returns_.InternalSwap(&other->num_returns_);
}

std::string PointCloud::GetTypeName() const {
  return "DTCC.PointCloud";
}


// ===================================================================

class Mesh::_Internal {
 public:
};

Mesh::Mesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vertices_(arena),
  faces_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Mesh)
}
Mesh::Mesh(const Mesh& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vertices_(from.vertices_),
      faces_(from.faces_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.Mesh)
}

inline void Mesh::SharedCtor() {
}

Mesh::~Mesh() {
  // @@protoc_insertion_point(destructor:DTCC.Mesh)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Mesh::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Mesh::ArenaDtor(void* object) {
  Mesh* _this = reinterpret_cast< Mesh* >(object);
  (void)_this;
}
void Mesh::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Mesh::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Mesh::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Mesh)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vertices_.Clear();
  faces_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Mesh::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float vertices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_vertices(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13) {
          _internal_add_vertices(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated uint32 faces = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_faces(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          _internal_add_faces(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Mesh::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Mesh)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float vertices = 1;
  if (this->_internal_vertices_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_vertices(), target);
  }

  // repeated uint32 faces = 2;
  {
    int byte_size = _faces_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_faces(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Mesh)
  return target;
}

size_t Mesh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Mesh)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float vertices = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_vertices_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  // repeated uint32 faces = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->faces_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _faces_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Mesh::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Mesh*>(
      &from));
}

void Mesh::MergeFrom(const Mesh& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Mesh)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vertices_.MergeFrom(from.vertices_);
  faces_.MergeFrom(from.faces_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Mesh::CopyFrom(const Mesh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Mesh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mesh::IsInitialized() const {
  return true;
}

void Mesh::InternalSwap(Mesh* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vertices_.InternalSwap(&other->vertices_);
  faces_.InternalSwap(&other->faces_);
}

std::string Mesh::GetTypeName() const {
  return "DTCC.Mesh";
}


// ===================================================================

class VolumeMesh::_Internal {
 public:
};

VolumeMesh::VolumeMesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vertices_(arena),
  cells_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.VolumeMesh)
}
VolumeMesh::VolumeMesh(const VolumeMesh& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vertices_(from.vertices_),
      cells_(from.cells_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DTCC.VolumeMesh)
}

inline void VolumeMesh::SharedCtor() {
}

VolumeMesh::~VolumeMesh() {
  // @@protoc_insertion_point(destructor:DTCC.VolumeMesh)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void VolumeMesh::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VolumeMesh::ArenaDtor(void* object) {
  VolumeMesh* _this = reinterpret_cast< VolumeMesh* >(object);
  (void)_this;
}
void VolumeMesh::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VolumeMesh::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VolumeMesh::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.VolumeMesh)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vertices_.Clear();
  cells_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VolumeMesh::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float vertices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_vertices(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13) {
          _internal_add_vertices(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated uint32 cells = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_cells(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          _internal_add_cells(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VolumeMesh::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.VolumeMesh)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float vertices = 1;
  if (this->_internal_vertices_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_vertices(), target);
  }

  // repeated uint32 cells = 2;
  {
    int byte_size = _cells_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_cells(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.VolumeMesh)
  return target;
}

size_t VolumeMesh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.VolumeMesh)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float vertices = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_vertices_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  // repeated uint32 cells = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->cells_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _cells_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VolumeMesh::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VolumeMesh*>(
      &from));
}

void VolumeMesh::MergeFrom(const VolumeMesh& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.VolumeMesh)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vertices_.MergeFrom(from.vertices_);
  cells_.MergeFrom(from.cells_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VolumeMesh::CopyFrom(const VolumeMesh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.VolumeMesh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeMesh::IsInitialized() const {
  return true;
}

void VolumeMesh::InternalSwap(VolumeMesh* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vertices_.InternalSwap(&other->vertices_);
  cells_.InternalSwap(&other->cells_);
}

std::string VolumeMesh::GetTypeName() const {
  return "DTCC.VolumeMesh";
}


// ===================================================================

class Grid::_Internal {
 public:
};

Grid::Grid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Grid)
}
Grid::Grid(const Grid& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&ystep_) -
    reinterpret_cast<char*>(&width_)) + sizeof(ystep_));
  // @@protoc_insertion_point(copy_constructor:DTCC.Grid)
}

inline void Grid::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ystep_) -
    reinterpret_cast<char*>(&width_)) + sizeof(ystep_));
}

Grid::~Grid() {
  // @@protoc_insertion_point(destructor:DTCC.Grid)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Grid::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Grid::ArenaDtor(void* object) {
  Grid* _this = reinterpret_cast< Grid* >(object);
  (void)_this;
}
void Grid::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Grid::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Grid::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Grid)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ystep_) -
      reinterpret_cast<char*>(&width_)) + sizeof(ystep_));
  _internal_metadata_.Clear<std::string>();
}

const char* Grid::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // float xstep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          xstep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float ystep = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          ystep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Grid::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Grid)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // int32 height = 2;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  // float xstep = 3;
  if (!(this->_internal_xstep() <= 0 && this->_internal_xstep() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_xstep(), target);
  }

  // float ystep = 4;
  if (!(this->_internal_ystep() <= 0 && this->_internal_ystep() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_ystep(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Grid)
  return target;
}

size_t Grid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Grid)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_width());
  }

  // int32 height = 2;
  if (this->_internal_height() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_height());
  }

  // float xstep = 3;
  if (!(this->_internal_xstep() <= 0 && this->_internal_xstep() >= 0)) {
    total_size += 1 + 4;
  }

  // float ystep = 4;
  if (!(this->_internal_ystep() <= 0 && this->_internal_ystep() >= 0)) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Grid::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Grid*>(
      &from));
}

void Grid::MergeFrom(const Grid& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Grid)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _internal_set_height(from._internal_height());
  }
  if (!(from._internal_xstep() <= 0 && from._internal_xstep() >= 0)) {
    _internal_set_xstep(from._internal_xstep());
  }
  if (!(from._internal_ystep() <= 0 && from._internal_ystep() >= 0)) {
    _internal_set_ystep(from._internal_ystep());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Grid::CopyFrom(const Grid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Grid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Grid::IsInitialized() const {
  return true;
}

void Grid::InternalSwap(Grid* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Grid, ystep_)
      + sizeof(Grid::ystep_)
      - PROTOBUF_FIELD_OFFSET(Grid, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

std::string Grid::GetTypeName() const {
  return "DTCC.Grid";
}


// ===================================================================

class VolumeGrid::_Internal {
 public:
};

VolumeGrid::VolumeGrid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.VolumeGrid)
}
VolumeGrid::VolumeGrid(const VolumeGrid& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&zstep_) -
    reinterpret_cast<char*>(&width_)) + sizeof(zstep_));
  // @@protoc_insertion_point(copy_constructor:DTCC.VolumeGrid)
}

inline void VolumeGrid::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&zstep_) -
    reinterpret_cast<char*>(&width_)) + sizeof(zstep_));
}

VolumeGrid::~VolumeGrid() {
  // @@protoc_insertion_point(destructor:DTCC.VolumeGrid)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void VolumeGrid::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VolumeGrid::ArenaDtor(void* object) {
  VolumeGrid* _this = reinterpret_cast< VolumeGrid* >(object);
  (void)_this;
}
void VolumeGrid::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VolumeGrid::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VolumeGrid::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.VolumeGrid)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&zstep_) -
      reinterpret_cast<char*>(&width_)) + sizeof(zstep_));
  _internal_metadata_.Clear<std::string>();
}

const char* VolumeGrid::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 depth = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // float xstep = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          xstep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float ystep = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          ystep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float zstep = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          zstep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VolumeGrid::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.VolumeGrid)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // int32 height = 2;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  // int32 depth = 3;
  if (this->_internal_depth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_depth(), target);
  }

  // float xstep = 4;
  if (!(this->_internal_xstep() <= 0 && this->_internal_xstep() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_xstep(), target);
  }

  // float ystep = 5;
  if (!(this->_internal_ystep() <= 0 && this->_internal_ystep() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_ystep(), target);
  }

  // float zstep = 6;
  if (!(this->_internal_zstep() <= 0 && this->_internal_zstep() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_zstep(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.VolumeGrid)
  return target;
}

size_t VolumeGrid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.VolumeGrid)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_width());
  }

  // int32 height = 2;
  if (this->_internal_height() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_height());
  }

  // int32 depth = 3;
  if (this->_internal_depth() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_depth());
  }

  // float xstep = 4;
  if (!(this->_internal_xstep() <= 0 && this->_internal_xstep() >= 0)) {
    total_size += 1 + 4;
  }

  // float ystep = 5;
  if (!(this->_internal_ystep() <= 0 && this->_internal_ystep() >= 0)) {
    total_size += 1 + 4;
  }

  // float zstep = 6;
  if (!(this->_internal_zstep() <= 0 && this->_internal_zstep() >= 0)) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VolumeGrid::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VolumeGrid*>(
      &from));
}

void VolumeGrid::MergeFrom(const VolumeGrid& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.VolumeGrid)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _internal_set_height(from._internal_height());
  }
  if (from._internal_depth() != 0) {
    _internal_set_depth(from._internal_depth());
  }
  if (!(from._internal_xstep() <= 0 && from._internal_xstep() >= 0)) {
    _internal_set_xstep(from._internal_xstep());
  }
  if (!(from._internal_ystep() <= 0 && from._internal_ystep() >= 0)) {
    _internal_set_ystep(from._internal_ystep());
  }
  if (!(from._internal_zstep() <= 0 && from._internal_zstep() >= 0)) {
    _internal_set_zstep(from._internal_zstep());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VolumeGrid::CopyFrom(const VolumeGrid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.VolumeGrid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeGrid::IsInitialized() const {
  return true;
}

void VolumeGrid::InternalSwap(VolumeGrid* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VolumeGrid, zstep_)
      + sizeof(VolumeGrid::zstep_)
      - PROTOBUF_FIELD_OFFSET(VolumeGrid, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

std::string VolumeGrid::GetTypeName() const {
  return "DTCC.VolumeGrid";
}


// ===================================================================

class Quantity::_Internal {
 public:
};

Quantity::Quantity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Quantity)
}
Quantity::Quantity(const Quantity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  unit_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_unit().empty()) {
    unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_unit(), 
      GetArenaForAllocation());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_description().empty()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  geometry_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_geometry().empty()) {
    geometry_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_geometry(), 
      GetArenaForAllocation());
  }
  dim_ = from.dim_;
  // @@protoc_insertion_point(copy_constructor:DTCC.Quantity)
}

inline void Quantity::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
unit_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
geometry_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
dim_ = 0;
}

Quantity::~Quantity() {
  // @@protoc_insertion_point(destructor:DTCC.Quantity)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Quantity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  unit_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  geometry_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Quantity::ArenaDtor(void* object) {
  Quantity* _this = reinterpret_cast< Quantity* >(object);
  (void)_this;
}
void Quantity::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Quantity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Quantity::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Quantity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  name_.ClearToEmpty();
  unit_.ClearToEmpty();
  description_.ClearToEmpty();
  geometry_.ClearToEmpty();
  dim_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Quantity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string unit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_unit();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string geometry = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_geometry();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 dim = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          dim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float values = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Quantity::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Quantity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Quantity.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string unit = 2;
  if (!this->_internal_unit().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_unit().data(), static_cast<int>(this->_internal_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Quantity.unit");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_unit(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Quantity.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // string geometry = 4;
  if (!this->_internal_geometry().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_geometry().data(), static_cast<int>(this->_internal_geometry().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Quantity.geometry");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_geometry(), target);
  }

  // int32 dim = 5;
  if (this->_internal_dim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_dim(), target);
  }

  // repeated float values = 6;
  if (this->_internal_values_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Quantity)
  return target;
}

size_t Quantity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Quantity)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float values = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string unit = 2;
  if (!this->_internal_unit().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_unit());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string geometry = 4;
  if (!this->_internal_geometry().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_geometry());
  }

  // int32 dim = 5;
  if (this->_internal_dim() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_dim());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Quantity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Quantity*>(
      &from));
}

void Quantity::MergeFrom(const Quantity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Quantity)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_unit().empty()) {
    _internal_set_unit(from._internal_unit());
  }
  if (!from._internal_description().empty()) {
    _internal_set_description(from._internal_description());
  }
  if (!from._internal_geometry().empty()) {
    _internal_set_geometry(from._internal_geometry());
  }
  if (from._internal_dim() != 0) {
    _internal_set_dim(from._internal_dim());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Quantity::CopyFrom(const Quantity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Quantity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quantity::IsInitialized() const {
  return true;
}

void Quantity::InternalSwap(Quantity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, GetArenaForAllocation(),
      &other->name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &unit_, GetArenaForAllocation(),
      &other->unit_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, GetArenaForAllocation(),
      &other->description_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &geometry_, GetArenaForAllocation(),
      &other->geometry_, other->GetArenaForAllocation()
  );
  swap(dim_, other->dim_);
}

std::string Quantity::GetTypeName() const {
  return "DTCC.Quantity";
}


// ===================================================================

class Raster::_Internal {
 public:
  static const ::DTCC::Grid& grid(const Raster* msg);
};

const ::DTCC::Grid&
Raster::_Internal::grid(const Raster* msg) {
  return *msg->grid_;
}
Raster::Raster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DTCC.Raster)
}
Raster::Raster(const Raster& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  unit_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_unit().empty()) {
    unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_unit(), 
      GetArenaForAllocation());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_description().empty()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_grid()) {
    grid_ = new ::DTCC::Grid(*from.grid_);
  } else {
    grid_ = nullptr;
  }
  dim_ = from.dim_;
  // @@protoc_insertion_point(copy_constructor:DTCC.Raster)
}

inline void Raster::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
unit_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&grid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dim_) -
    reinterpret_cast<char*>(&grid_)) + sizeof(dim_));
}

Raster::~Raster() {
  // @@protoc_insertion_point(destructor:DTCC.Raster)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Raster::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  unit_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete grid_;
}

void Raster::ArenaDtor(void* object) {
  Raster* _this = reinterpret_cast< Raster* >(object);
  (void)_this;
}
void Raster::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Raster::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Raster::Clear() {
// @@protoc_insertion_point(message_clear_start:DTCC.Raster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  name_.ClearToEmpty();
  unit_.ClearToEmpty();
  description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && grid_ != nullptr) {
    delete grid_;
  }
  grid_ = nullptr;
  dim_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Raster::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string unit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_unit();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .DTCC.Grid grid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_grid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 dim = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          dim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float values = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Raster::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DTCC.Raster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Raster.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string unit = 2;
  if (!this->_internal_unit().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_unit().data(), static_cast<int>(this->_internal_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Raster.unit");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_unit(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DTCC.Raster.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // .DTCC.Grid grid = 4;
  if (this->_internal_has_grid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::grid(this), target, stream);
  }

  // int32 dim = 5;
  if (this->_internal_dim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_dim(), target);
  }

  // repeated float values = 6;
  if (this->_internal_values_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DTCC.Raster)
  return target;
}

size_t Raster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DTCC.Raster)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float values = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string unit = 2;
  if (!this->_internal_unit().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_unit());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .DTCC.Grid grid = 4;
  if (this->_internal_has_grid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *grid_);
  }

  // int32 dim = 5;
  if (this->_internal_dim() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_dim());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Raster::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Raster*>(
      &from));
}

void Raster::MergeFrom(const Raster& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DTCC.Raster)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_unit().empty()) {
    _internal_set_unit(from._internal_unit());
  }
  if (!from._internal_description().empty()) {
    _internal_set_description(from._internal_description());
  }
  if (from._internal_has_grid()) {
    _internal_mutable_grid()->::DTCC::Grid::MergeFrom(from._internal_grid());
  }
  if (from._internal_dim() != 0) {
    _internal_set_dim(from._internal_dim());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Raster::CopyFrom(const Raster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DTCC.Raster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Raster::IsInitialized() const {
  return true;
}

void Raster::InternalSwap(Raster* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, GetArenaForAllocation(),
      &other->name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &unit_, GetArenaForAllocation(),
      &other->unit_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, GetArenaForAllocation(),
      &other->description_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Raster, dim_)
      + sizeof(Raster::dim_)
      - PROTOBUF_FIELD_OFFSET(Raster, grid_)>(
          reinterpret_cast<char*>(&grid_),
          reinterpret_cast<char*>(&other->grid_));
}

std::string Raster::GetTypeName() const {
  return "DTCC.Raster";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace DTCC
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::DTCC::Object_GeometryEntry_DoNotUse* Arena::CreateMaybeMessage< ::DTCC::Object_GeometryEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Object_GeometryEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Object* Arena::CreateMaybeMessage< ::DTCC::Object >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Object >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::City* Arena::CreateMaybeMessage< ::DTCC::City >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::City >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Building* Arena::CreateMaybeMessage< ::DTCC::Building >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Building >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Terrain* Arena::CreateMaybeMessage< ::DTCC::Terrain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Terrain >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::CityObject* Arena::CreateMaybeMessage< ::DTCC::CityObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::CityObject >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::BuildingPart* Arena::CreateMaybeMessage< ::DTCC::BuildingPart >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::BuildingPart >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Bounds* Arena::CreateMaybeMessage< ::DTCC::Bounds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Bounds >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Transform* Arena::CreateMaybeMessage< ::DTCC::Transform >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Transform >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::LineString* Arena::CreateMaybeMessage< ::DTCC::LineString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::LineString >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Geometry* Arena::CreateMaybeMessage< ::DTCC::Geometry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Geometry >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Surface* Arena::CreateMaybeMessage< ::DTCC::Surface >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Surface >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::MultiSurface* Arena::CreateMaybeMessage< ::DTCC::MultiSurface >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::MultiSurface >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::PointCloud* Arena::CreateMaybeMessage< ::DTCC::PointCloud >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::PointCloud >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Mesh* Arena::CreateMaybeMessage< ::DTCC::Mesh >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Mesh >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::VolumeMesh* Arena::CreateMaybeMessage< ::DTCC::VolumeMesh >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::VolumeMesh >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Grid* Arena::CreateMaybeMessage< ::DTCC::Grid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Grid >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::VolumeGrid* Arena::CreateMaybeMessage< ::DTCC::VolumeGrid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::VolumeGrid >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Quantity* Arena::CreateMaybeMessage< ::DTCC::Quantity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Quantity >(arena);
}
template<> PROTOBUF_NOINLINE ::DTCC::Raster* Arena::CreateMaybeMessage< ::DTCC::Raster >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DTCC::Raster >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
