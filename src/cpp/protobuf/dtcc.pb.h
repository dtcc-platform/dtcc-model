// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dtcc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dtcc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dtcc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dtcc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dtcc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace DTCC {
class Bounds;
struct BoundsDefaultTypeInternal;
extern BoundsDefaultTypeInternal _Bounds_default_instance_;
class Building;
struct BuildingDefaultTypeInternal;
extern BuildingDefaultTypeInternal _Building_default_instance_;
class BuildingPart;
struct BuildingPartDefaultTypeInternal;
extern BuildingPartDefaultTypeInternal _BuildingPart_default_instance_;
class City;
struct CityDefaultTypeInternal;
extern CityDefaultTypeInternal _City_default_instance_;
class CityObject;
struct CityObjectDefaultTypeInternal;
extern CityObjectDefaultTypeInternal _CityObject_default_instance_;
class Geometry;
struct GeometryDefaultTypeInternal;
extern GeometryDefaultTypeInternal _Geometry_default_instance_;
class Grid;
struct GridDefaultTypeInternal;
extern GridDefaultTypeInternal _Grid_default_instance_;
class LineString;
struct LineStringDefaultTypeInternal;
extern LineStringDefaultTypeInternal _LineString_default_instance_;
class Mesh;
struct MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class MultiSurface;
struct MultiSurfaceDefaultTypeInternal;
extern MultiSurfaceDefaultTypeInternal _MultiSurface_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_GeometryEntry_DoNotUse;
struct Object_GeometryEntry_DoNotUseDefaultTypeInternal;
extern Object_GeometryEntry_DoNotUseDefaultTypeInternal _Object_GeometryEntry_DoNotUse_default_instance_;
class PointCloud;
struct PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class Quantity;
struct QuantityDefaultTypeInternal;
extern QuantityDefaultTypeInternal _Quantity_default_instance_;
class Raster;
struct RasterDefaultTypeInternal;
extern RasterDefaultTypeInternal _Raster_default_instance_;
class Surface;
struct SurfaceDefaultTypeInternal;
extern SurfaceDefaultTypeInternal _Surface_default_instance_;
class Terrain;
struct TerrainDefaultTypeInternal;
extern TerrainDefaultTypeInternal _Terrain_default_instance_;
class Transform;
struct TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class VolumeGrid;
struct VolumeGridDefaultTypeInternal;
extern VolumeGridDefaultTypeInternal _VolumeGrid_default_instance_;
class VolumeMesh;
struct VolumeMeshDefaultTypeInternal;
extern VolumeMeshDefaultTypeInternal _VolumeMesh_default_instance_;
}  // namespace DTCC
PROTOBUF_NAMESPACE_OPEN
template<> ::DTCC::Bounds* Arena::CreateMaybeMessage<::DTCC::Bounds>(Arena*);
template<> ::DTCC::Building* Arena::CreateMaybeMessage<::DTCC::Building>(Arena*);
template<> ::DTCC::BuildingPart* Arena::CreateMaybeMessage<::DTCC::BuildingPart>(Arena*);
template<> ::DTCC::City* Arena::CreateMaybeMessage<::DTCC::City>(Arena*);
template<> ::DTCC::CityObject* Arena::CreateMaybeMessage<::DTCC::CityObject>(Arena*);
template<> ::DTCC::Geometry* Arena::CreateMaybeMessage<::DTCC::Geometry>(Arena*);
template<> ::DTCC::Grid* Arena::CreateMaybeMessage<::DTCC::Grid>(Arena*);
template<> ::DTCC::LineString* Arena::CreateMaybeMessage<::DTCC::LineString>(Arena*);
template<> ::DTCC::Mesh* Arena::CreateMaybeMessage<::DTCC::Mesh>(Arena*);
template<> ::DTCC::MultiSurface* Arena::CreateMaybeMessage<::DTCC::MultiSurface>(Arena*);
template<> ::DTCC::Object* Arena::CreateMaybeMessage<::DTCC::Object>(Arena*);
template<> ::DTCC::Object_GeometryEntry_DoNotUse* Arena::CreateMaybeMessage<::DTCC::Object_GeometryEntry_DoNotUse>(Arena*);
template<> ::DTCC::PointCloud* Arena::CreateMaybeMessage<::DTCC::PointCloud>(Arena*);
template<> ::DTCC::Quantity* Arena::CreateMaybeMessage<::DTCC::Quantity>(Arena*);
template<> ::DTCC::Raster* Arena::CreateMaybeMessage<::DTCC::Raster>(Arena*);
template<> ::DTCC::Surface* Arena::CreateMaybeMessage<::DTCC::Surface>(Arena*);
template<> ::DTCC::Terrain* Arena::CreateMaybeMessage<::DTCC::Terrain>(Arena*);
template<> ::DTCC::Transform* Arena::CreateMaybeMessage<::DTCC::Transform>(Arena*);
template<> ::DTCC::VolumeGrid* Arena::CreateMaybeMessage<::DTCC::VolumeGrid>(Arena*);
template<> ::DTCC::VolumeMesh* Arena::CreateMaybeMessage<::DTCC::VolumeMesh>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace DTCC {

// ===================================================================

class Object_GeometryEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Object_GeometryEntry_DoNotUse, 
    std::string, ::DTCC::Geometry,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Object_GeometryEntry_DoNotUse, 
    std::string, ::DTCC::Geometry,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Object_GeometryEntry_DoNotUse();
  explicit constexpr Object_GeometryEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Object_GeometryEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Object_GeometryEntry_DoNotUse& other);
  static const Object_GeometryEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Object_GeometryEntry_DoNotUse*>(&_Object_GeometryEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "DTCC.Object.GeometryEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Object final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  explicit constexpr Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Object& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kCity = 6,
    kBuilding = 7,
    kTerrain = 8,
    kCityObject = 9,
    kBuildingPart = 10,
    TYPE_NOT_SET = 0,
  };

  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return new Object();
  }

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Object* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kGeometryFieldNumber = 3,
    kQuantitiesFieldNumber = 4,
    kChildrenFieldNumber = 5,
    kIdFieldNumber = 1,
    kAttributesFieldNumber = 2,
    kCityFieldNumber = 6,
    kBuildingFieldNumber = 7,
    kTerrainFieldNumber = 8,
    kCityObjectFieldNumber = 9,
    kBuildingPartFieldNumber = 10,
  };
  // map<string, .DTCC.Geometry> geometry = 3;
  int geometry_size() const;
  private:
  int _internal_geometry_size() const;
  public:
  void clear_geometry();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >&
      _internal_geometry() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >*
      _internal_mutable_geometry();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >&
      geometry() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >*
      mutable_geometry();

  // repeated .DTCC.Quantity quantities = 4;
  int quantities_size() const;
  private:
  int _internal_quantities_size() const;
  public:
  void clear_quantities();
  ::DTCC::Quantity* mutable_quantities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Quantity >*
      mutable_quantities();
  private:
  const ::DTCC::Quantity& _internal_quantities(int index) const;
  ::DTCC::Quantity* _internal_add_quantities();
  public:
  const ::DTCC::Quantity& quantities(int index) const;
  ::DTCC::Quantity* add_quantities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Quantity >&
      quantities() const;

  // repeated .DTCC.Object children = 5;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::DTCC::Object* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Object >*
      mutable_children();
  private:
  const ::DTCC::Object& _internal_children(int index) const;
  ::DTCC::Object* _internal_add_children();
  public:
  const ::DTCC::Object& children(int index) const;
  ::DTCC::Object* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Object >&
      children() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string attributes = 2;
  void clear_attributes();
  const std::string& attributes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attributes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attributes();
  PROTOBUF_MUST_USE_RESULT std::string* release_attributes();
  void set_allocated_attributes(std::string* attributes);
  private:
  const std::string& _internal_attributes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributes(const std::string& value);
  std::string* _internal_mutable_attributes();
  public:

  // .DTCC.City city = 6;
  bool has_city() const;
  private:
  bool _internal_has_city() const;
  public:
  void clear_city();
  const ::DTCC::City& city() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::City* release_city();
  ::DTCC::City* mutable_city();
  void set_allocated_city(::DTCC::City* city);
  private:
  const ::DTCC::City& _internal_city() const;
  ::DTCC::City* _internal_mutable_city();
  public:
  void unsafe_arena_set_allocated_city(
      ::DTCC::City* city);
  ::DTCC::City* unsafe_arena_release_city();

  // .DTCC.Building building = 7;
  bool has_building() const;
  private:
  bool _internal_has_building() const;
  public:
  void clear_building();
  const ::DTCC::Building& building() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::Building* release_building();
  ::DTCC::Building* mutable_building();
  void set_allocated_building(::DTCC::Building* building);
  private:
  const ::DTCC::Building& _internal_building() const;
  ::DTCC::Building* _internal_mutable_building();
  public:
  void unsafe_arena_set_allocated_building(
      ::DTCC::Building* building);
  ::DTCC::Building* unsafe_arena_release_building();

  // .DTCC.Terrain terrain = 8;
  bool has_terrain() const;
  private:
  bool _internal_has_terrain() const;
  public:
  void clear_terrain();
  const ::DTCC::Terrain& terrain() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::Terrain* release_terrain();
  ::DTCC::Terrain* mutable_terrain();
  void set_allocated_terrain(::DTCC::Terrain* terrain);
  private:
  const ::DTCC::Terrain& _internal_terrain() const;
  ::DTCC::Terrain* _internal_mutable_terrain();
  public:
  void unsafe_arena_set_allocated_terrain(
      ::DTCC::Terrain* terrain);
  ::DTCC::Terrain* unsafe_arena_release_terrain();

  // .DTCC.CityObject city_object = 9;
  bool has_city_object() const;
  private:
  bool _internal_has_city_object() const;
  public:
  void clear_city_object();
  const ::DTCC::CityObject& city_object() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::CityObject* release_city_object();
  ::DTCC::CityObject* mutable_city_object();
  void set_allocated_city_object(::DTCC::CityObject* city_object);
  private:
  const ::DTCC::CityObject& _internal_city_object() const;
  ::DTCC::CityObject* _internal_mutable_city_object();
  public:
  void unsafe_arena_set_allocated_city_object(
      ::DTCC::CityObject* city_object);
  ::DTCC::CityObject* unsafe_arena_release_city_object();

  // .DTCC.BuildingPart building_part = 10;
  bool has_building_part() const;
  private:
  bool _internal_has_building_part() const;
  public:
  void clear_building_part();
  const ::DTCC::BuildingPart& building_part() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::BuildingPart* release_building_part();
  ::DTCC::BuildingPart* mutable_building_part();
  void set_allocated_building_part(::DTCC::BuildingPart* building_part);
  private:
  const ::DTCC::BuildingPart& _internal_building_part() const;
  ::DTCC::BuildingPart* _internal_mutable_building_part();
  public:
  void unsafe_arena_set_allocated_building_part(
      ::DTCC::BuildingPart* building_part);
  ::DTCC::BuildingPart* unsafe_arena_release_building_part();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:DTCC.Object)
 private:
  class _Internal;
  void set_has_city();
  void set_has_building();
  void set_has_terrain();
  void set_has_city_object();
  void set_has_building_part();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Object_GeometryEntry_DoNotUse,
      std::string, ::DTCC::Geometry,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> geometry_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Quantity > quantities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Object > children_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attributes_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::DTCC::City* city_;
    ::DTCC::Building* building_;
    ::DTCC::Terrain* terrain_;
    ::DTCC::CityObject* city_object_;
    ::DTCC::BuildingPart* building_part_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class City final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.City) */ {
 public:
  inline City() : City(nullptr) {}
  ~City() override;
  explicit constexpr City(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  City(const City& from);
  City(City&& from) noexcept
    : City() {
    *this = ::std::move(from);
  }

  inline City& operator=(const City& from) {
    CopyFrom(from);
    return *this;
  }
  inline City& operator=(City&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const City& default_instance() {
    return *internal_default_instance();
  }
  static inline const City* internal_default_instance() {
    return reinterpret_cast<const City*>(
               &_City_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(City& a, City& b) {
    a.Swap(&b);
  }
  inline void Swap(City* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(City* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline City* New() const final {
    return new City();
  }

  City* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<City>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const City& from);
  void MergeFrom(const City& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(City* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.City";
  }
  protected:
  explicit City(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DTCC.City)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Building final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Building) */ {
 public:
  inline Building() : Building(nullptr) {}
  ~Building() override;
  explicit constexpr Building(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Building(const Building& from);
  Building(Building&& from) noexcept
    : Building() {
    *this = ::std::move(from);
  }

  inline Building& operator=(const Building& from) {
    CopyFrom(from);
    return *this;
  }
  inline Building& operator=(Building&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Building& default_instance() {
    return *internal_default_instance();
  }
  static inline const Building* internal_default_instance() {
    return reinterpret_cast<const Building*>(
               &_Building_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Building& a, Building& b) {
    a.Swap(&b);
  }
  inline void Swap(Building* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Building* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Building* New() const final {
    return new Building();
  }

  Building* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Building>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Building& from);
  void MergeFrom(const Building& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Building* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Building";
  }
  protected:
  explicit Building(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DTCC.Building)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Terrain final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Terrain) */ {
 public:
  inline Terrain() : Terrain(nullptr) {}
  ~Terrain() override;
  explicit constexpr Terrain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Terrain(const Terrain& from);
  Terrain(Terrain&& from) noexcept
    : Terrain() {
    *this = ::std::move(from);
  }

  inline Terrain& operator=(const Terrain& from) {
    CopyFrom(from);
    return *this;
  }
  inline Terrain& operator=(Terrain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Terrain& default_instance() {
    return *internal_default_instance();
  }
  static inline const Terrain* internal_default_instance() {
    return reinterpret_cast<const Terrain*>(
               &_Terrain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Terrain& a, Terrain& b) {
    a.Swap(&b);
  }
  inline void Swap(Terrain* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Terrain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Terrain* New() const final {
    return new Terrain();
  }

  Terrain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Terrain>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Terrain& from);
  void MergeFrom(const Terrain& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Terrain* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Terrain";
  }
  protected:
  explicit Terrain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DTCC.Terrain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class CityObject final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.CityObject) */ {
 public:
  inline CityObject() : CityObject(nullptr) {}
  ~CityObject() override;
  explicit constexpr CityObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CityObject(const CityObject& from);
  CityObject(CityObject&& from) noexcept
    : CityObject() {
    *this = ::std::move(from);
  }

  inline CityObject& operator=(const CityObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline CityObject& operator=(CityObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CityObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const CityObject* internal_default_instance() {
    return reinterpret_cast<const CityObject*>(
               &_CityObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CityObject& a, CityObject& b) {
    a.Swap(&b);
  }
  inline void Swap(CityObject* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CityObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CityObject* New() const final {
    return new CityObject();
  }

  CityObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CityObject>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CityObject& from);
  void MergeFrom(const CityObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CityObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.CityObject";
  }
  protected:
  explicit CityObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DTCC.CityObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class BuildingPart final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.BuildingPart) */ {
 public:
  inline BuildingPart() : BuildingPart(nullptr) {}
  ~BuildingPart() override;
  explicit constexpr BuildingPart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuildingPart(const BuildingPart& from);
  BuildingPart(BuildingPart&& from) noexcept
    : BuildingPart() {
    *this = ::std::move(from);
  }

  inline BuildingPart& operator=(const BuildingPart& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildingPart& operator=(BuildingPart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BuildingPart& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildingPart* internal_default_instance() {
    return reinterpret_cast<const BuildingPart*>(
               &_BuildingPart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BuildingPart& a, BuildingPart& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildingPart* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildingPart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildingPart* New() const final {
    return new BuildingPart();
  }

  BuildingPart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildingPart>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BuildingPart& from);
  void MergeFrom(const BuildingPart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuildingPart* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.BuildingPart";
  }
  protected:
  explicit BuildingPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DTCC.BuildingPart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Bounds final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Bounds) */ {
 public:
  inline Bounds() : Bounds(nullptr) {}
  ~Bounds() override;
  explicit constexpr Bounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bounds(const Bounds& from);
  Bounds(Bounds&& from) noexcept
    : Bounds() {
    *this = ::std::move(from);
  }

  inline Bounds& operator=(const Bounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bounds& operator=(Bounds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Bounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bounds* internal_default_instance() {
    return reinterpret_cast<const Bounds*>(
               &_Bounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Bounds& a, Bounds& b) {
    a.Swap(&b);
  }
  inline void Swap(Bounds* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bounds* New() const final {
    return new Bounds();
  }

  Bounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bounds>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Bounds& from);
  void MergeFrom(const Bounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Bounds";
  }
  protected:
  explicit Bounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXminFieldNumber = 1,
    kYminFieldNumber = 2,
    kZminFieldNumber = 3,
    kXmaxFieldNumber = 4,
    kYmaxFieldNumber = 5,
    kZmaxFieldNumber = 6,
  };
  // float xmin = 1;
  void clear_xmin();
  float xmin() const;
  void set_xmin(float value);
  private:
  float _internal_xmin() const;
  void _internal_set_xmin(float value);
  public:

  // float ymin = 2;
  void clear_ymin();
  float ymin() const;
  void set_ymin(float value);
  private:
  float _internal_ymin() const;
  void _internal_set_ymin(float value);
  public:

  // float zmin = 3;
  void clear_zmin();
  float zmin() const;
  void set_zmin(float value);
  private:
  float _internal_zmin() const;
  void _internal_set_zmin(float value);
  public:

  // float xmax = 4;
  void clear_xmax();
  float xmax() const;
  void set_xmax(float value);
  private:
  float _internal_xmax() const;
  void _internal_set_xmax(float value);
  public:

  // float ymax = 5;
  void clear_ymax();
  float ymax() const;
  void set_ymax(float value);
  private:
  float _internal_ymax() const;
  void _internal_set_ymax(float value);
  public:

  // float zmax = 6;
  void clear_zmax();
  float zmax() const;
  void set_zmax(float value);
  private:
  float _internal_zmax() const;
  void _internal_set_zmax(float value);
  public:

  // @@protoc_insertion_point(class_scope:DTCC.Bounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float xmin_;
  float ymin_;
  float zmin_;
  float xmax_;
  float ymax_;
  float zmax_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Transform final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  ~Transform() override;
  explicit constexpr Transform(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transform(const Transform& from);
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Transform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transform* New() const final {
    return new Transform();
  }

  Transform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transform* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Transform";
  }
  protected:
  explicit Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffineFieldNumber = 2,
    kSrsFieldNumber = 1,
  };
  // repeated float affine = 2;
  int affine_size() const;
  private:
  int _internal_affine_size() const;
  public:
  void clear_affine();
  private:
  float _internal_affine(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_affine() const;
  void _internal_add_affine(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_affine();
  public:
  float affine(int index) const;
  void set_affine(int index, float value);
  void add_affine(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      affine() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_affine();

  // string srs = 1;
  void clear_srs();
  const std::string& srs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srs();
  PROTOBUF_MUST_USE_RESULT std::string* release_srs();
  void set_allocated_srs(std::string* srs);
  private:
  const std::string& _internal_srs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srs(const std::string& value);
  std::string* _internal_mutable_srs();
  public:

  // @@protoc_insertion_point(class_scope:DTCC.Transform)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > affine_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class LineString final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.LineString) */ {
 public:
  inline LineString() : LineString(nullptr) {}
  ~LineString() override;
  explicit constexpr LineString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineString(const LineString& from);
  LineString(LineString&& from) noexcept
    : LineString() {
    *this = ::std::move(from);
  }

  inline LineString& operator=(const LineString& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineString& operator=(LineString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LineString& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineString* internal_default_instance() {
    return reinterpret_cast<const LineString*>(
               &_LineString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LineString& a, LineString& b) {
    a.Swap(&b);
  }
  inline void Swap(LineString* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LineString* New() const final {
    return new LineString();
  }

  LineString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LineString>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LineString& from);
  void MergeFrom(const LineString& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LineString* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.LineString";
  }
  protected:
  explicit LineString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
  };
  // repeated float vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  private:
  float _internal_vertices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vertices() const;
  void _internal_add_vertices(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vertices();
  public:
  float vertices(int index) const;
  void set_vertices(int index, float value);
  void add_vertices(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vertices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vertices();

  // @@protoc_insertion_point(class_scope:DTCC.LineString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vertices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Geometry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Geometry) */ {
 public:
  inline Geometry() : Geometry(nullptr) {}
  ~Geometry() override;
  explicit constexpr Geometry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Geometry(const Geometry& from);
  Geometry(Geometry&& from) noexcept
    : Geometry() {
    *this = ::std::move(from);
  }

  inline Geometry& operator=(const Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geometry& operator=(Geometry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Geometry& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kSurface = 3,
    kMultiSurface = 4,
    kPointCloud = 5,
    kMesh = 6,
    kVolumeMesh = 7,
    kGrid = 8,
    kVolumeGrid = 9,
    TYPE_NOT_SET = 0,
  };

  static inline const Geometry* internal_default_instance() {
    return reinterpret_cast<const Geometry*>(
               &_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Geometry& a, Geometry& b) {
    a.Swap(&b);
  }
  inline void Swap(Geometry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Geometry* New() const final {
    return new Geometry();
  }

  Geometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Geometry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Geometry& from);
  void MergeFrom(const Geometry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Geometry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Geometry";
  }
  protected:
  explicit Geometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundsFieldNumber = 1,
    kTransformFieldNumber = 2,
    kSurfaceFieldNumber = 3,
    kMultiSurfaceFieldNumber = 4,
    kPointCloudFieldNumber = 5,
    kMeshFieldNumber = 6,
    kVolumeMeshFieldNumber = 7,
    kGridFieldNumber = 8,
    kVolumeGridFieldNumber = 9,
  };
  // .DTCC.Bounds bounds = 1;
  bool has_bounds() const;
  private:
  bool _internal_has_bounds() const;
  public:
  void clear_bounds();
  const ::DTCC::Bounds& bounds() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::Bounds* release_bounds();
  ::DTCC::Bounds* mutable_bounds();
  void set_allocated_bounds(::DTCC::Bounds* bounds);
  private:
  const ::DTCC::Bounds& _internal_bounds() const;
  ::DTCC::Bounds* _internal_mutable_bounds();
  public:
  void unsafe_arena_set_allocated_bounds(
      ::DTCC::Bounds* bounds);
  ::DTCC::Bounds* unsafe_arena_release_bounds();

  // .DTCC.Transform transform = 2;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::DTCC::Transform& transform() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::Transform* release_transform();
  ::DTCC::Transform* mutable_transform();
  void set_allocated_transform(::DTCC::Transform* transform);
  private:
  const ::DTCC::Transform& _internal_transform() const;
  ::DTCC::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::DTCC::Transform* transform);
  ::DTCC::Transform* unsafe_arena_release_transform();

  // .DTCC.Surface surface = 3;
  bool has_surface() const;
  private:
  bool _internal_has_surface() const;
  public:
  void clear_surface();
  const ::DTCC::Surface& surface() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::Surface* release_surface();
  ::DTCC::Surface* mutable_surface();
  void set_allocated_surface(::DTCC::Surface* surface);
  private:
  const ::DTCC::Surface& _internal_surface() const;
  ::DTCC::Surface* _internal_mutable_surface();
  public:
  void unsafe_arena_set_allocated_surface(
      ::DTCC::Surface* surface);
  ::DTCC::Surface* unsafe_arena_release_surface();

  // .DTCC.MultiSurface multi_surface = 4;
  bool has_multi_surface() const;
  private:
  bool _internal_has_multi_surface() const;
  public:
  void clear_multi_surface();
  const ::DTCC::MultiSurface& multi_surface() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::MultiSurface* release_multi_surface();
  ::DTCC::MultiSurface* mutable_multi_surface();
  void set_allocated_multi_surface(::DTCC::MultiSurface* multi_surface);
  private:
  const ::DTCC::MultiSurface& _internal_multi_surface() const;
  ::DTCC::MultiSurface* _internal_mutable_multi_surface();
  public:
  void unsafe_arena_set_allocated_multi_surface(
      ::DTCC::MultiSurface* multi_surface);
  ::DTCC::MultiSurface* unsafe_arena_release_multi_surface();

  // .DTCC.PointCloud point_cloud = 5;
  bool has_point_cloud() const;
  private:
  bool _internal_has_point_cloud() const;
  public:
  void clear_point_cloud();
  const ::DTCC::PointCloud& point_cloud() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::PointCloud* release_point_cloud();
  ::DTCC::PointCloud* mutable_point_cloud();
  void set_allocated_point_cloud(::DTCC::PointCloud* point_cloud);
  private:
  const ::DTCC::PointCloud& _internal_point_cloud() const;
  ::DTCC::PointCloud* _internal_mutable_point_cloud();
  public:
  void unsafe_arena_set_allocated_point_cloud(
      ::DTCC::PointCloud* point_cloud);
  ::DTCC::PointCloud* unsafe_arena_release_point_cloud();

  // .DTCC.Mesh mesh = 6;
  bool has_mesh() const;
  private:
  bool _internal_has_mesh() const;
  public:
  void clear_mesh();
  const ::DTCC::Mesh& mesh() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::Mesh* release_mesh();
  ::DTCC::Mesh* mutable_mesh();
  void set_allocated_mesh(::DTCC::Mesh* mesh);
  private:
  const ::DTCC::Mesh& _internal_mesh() const;
  ::DTCC::Mesh* _internal_mutable_mesh();
  public:
  void unsafe_arena_set_allocated_mesh(
      ::DTCC::Mesh* mesh);
  ::DTCC::Mesh* unsafe_arena_release_mesh();

  // .DTCC.VolumeMesh volume_mesh = 7;
  bool has_volume_mesh() const;
  private:
  bool _internal_has_volume_mesh() const;
  public:
  void clear_volume_mesh();
  const ::DTCC::VolumeMesh& volume_mesh() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::VolumeMesh* release_volume_mesh();
  ::DTCC::VolumeMesh* mutable_volume_mesh();
  void set_allocated_volume_mesh(::DTCC::VolumeMesh* volume_mesh);
  private:
  const ::DTCC::VolumeMesh& _internal_volume_mesh() const;
  ::DTCC::VolumeMesh* _internal_mutable_volume_mesh();
  public:
  void unsafe_arena_set_allocated_volume_mesh(
      ::DTCC::VolumeMesh* volume_mesh);
  ::DTCC::VolumeMesh* unsafe_arena_release_volume_mesh();

  // .DTCC.Grid grid = 8;
  bool has_grid() const;
  private:
  bool _internal_has_grid() const;
  public:
  void clear_grid();
  const ::DTCC::Grid& grid() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::Grid* release_grid();
  ::DTCC::Grid* mutable_grid();
  void set_allocated_grid(::DTCC::Grid* grid);
  private:
  const ::DTCC::Grid& _internal_grid() const;
  ::DTCC::Grid* _internal_mutable_grid();
  public:
  void unsafe_arena_set_allocated_grid(
      ::DTCC::Grid* grid);
  ::DTCC::Grid* unsafe_arena_release_grid();

  // .DTCC.VolumeGrid volume_grid = 9;
  bool has_volume_grid() const;
  private:
  bool _internal_has_volume_grid() const;
  public:
  void clear_volume_grid();
  const ::DTCC::VolumeGrid& volume_grid() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::VolumeGrid* release_volume_grid();
  ::DTCC::VolumeGrid* mutable_volume_grid();
  void set_allocated_volume_grid(::DTCC::VolumeGrid* volume_grid);
  private:
  const ::DTCC::VolumeGrid& _internal_volume_grid() const;
  ::DTCC::VolumeGrid* _internal_mutable_volume_grid();
  public:
  void unsafe_arena_set_allocated_volume_grid(
      ::DTCC::VolumeGrid* volume_grid);
  ::DTCC::VolumeGrid* unsafe_arena_release_volume_grid();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:DTCC.Geometry)
 private:
  class _Internal;
  void set_has_surface();
  void set_has_multi_surface();
  void set_has_point_cloud();
  void set_has_mesh();
  void set_has_volume_mesh();
  void set_has_grid();
  void set_has_volume_grid();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::DTCC::Bounds* bounds_;
  ::DTCC::Transform* transform_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::DTCC::Surface* surface_;
    ::DTCC::MultiSurface* multi_surface_;
    ::DTCC::PointCloud* point_cloud_;
    ::DTCC::Mesh* mesh_;
    ::DTCC::VolumeMesh* volume_mesh_;
    ::DTCC::Grid* grid_;
    ::DTCC::VolumeGrid* volume_grid_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Surface final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Surface) */ {
 public:
  inline Surface() : Surface(nullptr) {}
  ~Surface() override;
  explicit constexpr Surface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Surface(const Surface& from);
  Surface(Surface&& from) noexcept
    : Surface() {
    *this = ::std::move(from);
  }

  inline Surface& operator=(const Surface& from) {
    CopyFrom(from);
    return *this;
  }
  inline Surface& operator=(Surface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Surface& default_instance() {
    return *internal_default_instance();
  }
  static inline const Surface* internal_default_instance() {
    return reinterpret_cast<const Surface*>(
               &_Surface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Surface& a, Surface& b) {
    a.Swap(&b);
  }
  inline void Swap(Surface* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Surface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Surface* New() const final {
    return new Surface();
  }

  Surface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Surface>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Surface& from);
  void MergeFrom(const Surface& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Surface* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Surface";
  }
  protected:
  explicit Surface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kNormalFieldNumber = 2,
    kHolesFieldNumber = 3,
  };
  // repeated float vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  private:
  float _internal_vertices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vertices() const;
  void _internal_add_vertices(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vertices();
  public:
  float vertices(int index) const;
  void set_vertices(int index, float value);
  void add_vertices(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vertices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vertices();

  // repeated float normal = 2;
  int normal_size() const;
  private:
  int _internal_normal_size() const;
  public:
  void clear_normal();
  private:
  float _internal_normal(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_normal() const;
  void _internal_add_normal(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_normal();
  public:
  float normal(int index) const;
  void set_normal(int index, float value);
  void add_normal(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      normal() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_normal();

  // repeated .DTCC.LineString holes = 3;
  int holes_size() const;
  private:
  int _internal_holes_size() const;
  public:
  void clear_holes();
  ::DTCC::LineString* mutable_holes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::LineString >*
      mutable_holes();
  private:
  const ::DTCC::LineString& _internal_holes(int index) const;
  ::DTCC::LineString* _internal_add_holes();
  public:
  const ::DTCC::LineString& holes(int index) const;
  ::DTCC::LineString* add_holes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::LineString >&
      holes() const;

  // @@protoc_insertion_point(class_scope:DTCC.Surface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vertices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > normal_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::LineString > holes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class MultiSurface final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.MultiSurface) */ {
 public:
  inline MultiSurface() : MultiSurface(nullptr) {}
  ~MultiSurface() override;
  explicit constexpr MultiSurface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiSurface(const MultiSurface& from);
  MultiSurface(MultiSurface&& from) noexcept
    : MultiSurface() {
    *this = ::std::move(from);
  }

  inline MultiSurface& operator=(const MultiSurface& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiSurface& operator=(MultiSurface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MultiSurface& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiSurface* internal_default_instance() {
    return reinterpret_cast<const MultiSurface*>(
               &_MultiSurface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MultiSurface& a, MultiSurface& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiSurface* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiSurface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiSurface* New() const final {
    return new MultiSurface();
  }

  MultiSurface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiSurface>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MultiSurface& from);
  void MergeFrom(const MultiSurface& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultiSurface* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.MultiSurface";
  }
  protected:
  explicit MultiSurface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSurfacesFieldNumber = 1,
  };
  // repeated .DTCC.Surface surfaces = 1;
  int surfaces_size() const;
  private:
  int _internal_surfaces_size() const;
  public:
  void clear_surfaces();
  ::DTCC::Surface* mutable_surfaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Surface >*
      mutable_surfaces();
  private:
  const ::DTCC::Surface& _internal_surfaces(int index) const;
  ::DTCC::Surface* _internal_add_surfaces();
  public:
  const ::DTCC::Surface& surfaces(int index) const;
  ::DTCC::Surface* add_surfaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Surface >&
      surfaces() const;

  // @@protoc_insertion_point(class_scope:DTCC.MultiSurface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Surface > surfaces_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class PointCloud final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.PointCloud) */ {
 public:
  inline PointCloud() : PointCloud(nullptr) {}
  ~PointCloud() override;
  explicit constexpr PointCloud(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointCloud(const PointCloud& from);
  PointCloud(PointCloud&& from) noexcept
    : PointCloud() {
    *this = ::std::move(from);
  }

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointCloud& operator=(PointCloud&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PointCloud& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PointCloud& a, PointCloud& b) {
    a.Swap(&b);
  }
  inline void Swap(PointCloud* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointCloud* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PointCloud* New() const final {
    return new PointCloud();
  }

  PointCloud* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PointCloud>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PointCloud* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.PointCloud";
  }
  protected:
  explicit PointCloud(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kClassificationFieldNumber = 2,
    kIntensityFieldNumber = 3,
    kReturnNumberFieldNumber = 4,
    kNumReturnsFieldNumber = 5,
  };
  // repeated float points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  private:
  float _internal_points(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_points() const;
  void _internal_add_points(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_points();
  public:
  float points(int index) const;
  void set_points(int index, float value);
  void add_points(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_points();

  // repeated uint32 classification = 2;
  int classification_size() const;
  private:
  int _internal_classification_size() const;
  public:
  void clear_classification();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_classification(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_classification() const;
  void _internal_add_classification(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_classification();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 classification(int index) const;
  void set_classification(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_classification(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      classification() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_classification();

  // repeated uint32 intensity = 3;
  int intensity_size() const;
  private:
  int _internal_intensity_size() const;
  public:
  void clear_intensity();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_intensity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_intensity() const;
  void _internal_add_intensity(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_intensity();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 intensity(int index) const;
  void set_intensity(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_intensity(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      intensity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_intensity();

  // repeated uint32 return_number = 4;
  int return_number_size() const;
  private:
  int _internal_return_number_size() const;
  public:
  void clear_return_number();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_return_number(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_return_number() const;
  void _internal_add_return_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_return_number();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 return_number(int index) const;
  void set_return_number(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_return_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      return_number() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_return_number();

  // repeated uint32 num_returns = 5;
  int num_returns_size() const;
  private:
  int _internal_num_returns_size() const;
  public:
  void clear_num_returns();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_returns(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_num_returns() const;
  void _internal_add_num_returns(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_num_returns();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 num_returns(int index) const;
  void set_num_returns(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_num_returns(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      num_returns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_num_returns();

  // @@protoc_insertion_point(class_scope:DTCC.PointCloud)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > points_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > classification_;
  mutable std::atomic<int> _classification_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > intensity_;
  mutable std::atomic<int> _intensity_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > return_number_;
  mutable std::atomic<int> _return_number_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > num_returns_;
  mutable std::atomic<int> _num_returns_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Mesh final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Mesh) */ {
 public:
  inline Mesh() : Mesh(nullptr) {}
  ~Mesh() override;
  explicit constexpr Mesh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mesh(const Mesh& from);
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Mesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Mesh* New() const final {
    return new Mesh();
  }

  Mesh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mesh* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Mesh";
  }
  protected:
  explicit Mesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kFacesFieldNumber = 2,
  };
  // repeated float vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  private:
  float _internal_vertices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vertices() const;
  void _internal_add_vertices(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vertices();
  public:
  float vertices(int index) const;
  void set_vertices(int index, float value);
  void add_vertices(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vertices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vertices();

  // repeated uint32 faces = 2;
  int faces_size() const;
  private:
  int _internal_faces_size() const;
  public:
  void clear_faces();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_faces(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_faces() const;
  void _internal_add_faces(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_faces();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 faces(int index) const;
  void set_faces(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_faces(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      faces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_faces();

  // @@protoc_insertion_point(class_scope:DTCC.Mesh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vertices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > faces_;
  mutable std::atomic<int> _faces_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class VolumeMesh final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.VolumeMesh) */ {
 public:
  inline VolumeMesh() : VolumeMesh(nullptr) {}
  ~VolumeMesh() override;
  explicit constexpr VolumeMesh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VolumeMesh(const VolumeMesh& from);
  VolumeMesh(VolumeMesh&& from) noexcept
    : VolumeMesh() {
    *this = ::std::move(from);
  }

  inline VolumeMesh& operator=(const VolumeMesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeMesh& operator=(VolumeMesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VolumeMesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeMesh* internal_default_instance() {
    return reinterpret_cast<const VolumeMesh*>(
               &_VolumeMesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VolumeMesh& a, VolumeMesh& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeMesh* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeMesh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeMesh* New() const final {
    return new VolumeMesh();
  }

  VolumeMesh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeMesh>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VolumeMesh& from);
  void MergeFrom(const VolumeMesh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VolumeMesh* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.VolumeMesh";
  }
  protected:
  explicit VolumeMesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kCellsFieldNumber = 2,
  };
  // repeated float vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  private:
  float _internal_vertices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vertices() const;
  void _internal_add_vertices(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vertices();
  public:
  float vertices(int index) const;
  void set_vertices(int index, float value);
  void add_vertices(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vertices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vertices();

  // repeated uint32 cells = 2;
  int cells_size() const;
  private:
  int _internal_cells_size() const;
  public:
  void clear_cells();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cells(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_cells() const;
  void _internal_add_cells(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_cells();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 cells(int index) const;
  void set_cells(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_cells(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      cells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_cells();

  // @@protoc_insertion_point(class_scope:DTCC.VolumeMesh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vertices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > cells_;
  mutable std::atomic<int> _cells_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Grid final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Grid) */ {
 public:
  inline Grid() : Grid(nullptr) {}
  ~Grid() override;
  explicit constexpr Grid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid(const Grid& from);
  Grid(Grid&& from) noexcept
    : Grid() {
    *this = ::std::move(from);
  }

  inline Grid& operator=(const Grid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid& operator=(Grid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Grid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid* internal_default_instance() {
    return reinterpret_cast<const Grid*>(
               &_Grid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Grid& a, Grid& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Grid* New() const final {
    return new Grid();
  }

  Grid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Grid>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Grid& from);
  void MergeFrom(const Grid& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Grid* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Grid";
  }
  protected:
  explicit Grid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kXstepFieldNumber = 3,
    kYstepFieldNumber = 4,
  };
  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float xstep = 3;
  void clear_xstep();
  float xstep() const;
  void set_xstep(float value);
  private:
  float _internal_xstep() const;
  void _internal_set_xstep(float value);
  public:

  // float ystep = 4;
  void clear_ystep();
  float ystep() const;
  void set_ystep(float value);
  private:
  float _internal_ystep() const;
  void _internal_set_ystep(float value);
  public:

  // @@protoc_insertion_point(class_scope:DTCC.Grid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  float xstep_;
  float ystep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class VolumeGrid final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.VolumeGrid) */ {
 public:
  inline VolumeGrid() : VolumeGrid(nullptr) {}
  ~VolumeGrid() override;
  explicit constexpr VolumeGrid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VolumeGrid(const VolumeGrid& from);
  VolumeGrid(VolumeGrid&& from) noexcept
    : VolumeGrid() {
    *this = ::std::move(from);
  }

  inline VolumeGrid& operator=(const VolumeGrid& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeGrid& operator=(VolumeGrid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VolumeGrid& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeGrid* internal_default_instance() {
    return reinterpret_cast<const VolumeGrid*>(
               &_VolumeGrid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VolumeGrid& a, VolumeGrid& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeGrid* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeGrid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeGrid* New() const final {
    return new VolumeGrid();
  }

  VolumeGrid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeGrid>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VolumeGrid& from);
  void MergeFrom(const VolumeGrid& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VolumeGrid* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.VolumeGrid";
  }
  protected:
  explicit VolumeGrid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kDepthFieldNumber = 3,
    kXstepFieldNumber = 4,
    kYstepFieldNumber = 5,
    kZstepFieldNumber = 6,
  };
  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 depth = 3;
  void clear_depth();
  ::PROTOBUF_NAMESPACE_ID::int32 depth() const;
  void set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_depth() const;
  void _internal_set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float xstep = 4;
  void clear_xstep();
  float xstep() const;
  void set_xstep(float value);
  private:
  float _internal_xstep() const;
  void _internal_set_xstep(float value);
  public:

  // float ystep = 5;
  void clear_ystep();
  float ystep() const;
  void set_ystep(float value);
  private:
  float _internal_ystep() const;
  void _internal_set_ystep(float value);
  public:

  // float zstep = 6;
  void clear_zstep();
  float zstep() const;
  void set_zstep(float value);
  private:
  float _internal_zstep() const;
  void _internal_set_zstep(float value);
  public:

  // @@protoc_insertion_point(class_scope:DTCC.VolumeGrid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 depth_;
  float xstep_;
  float ystep_;
  float zstep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Quantity final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Quantity) */ {
 public:
  inline Quantity() : Quantity(nullptr) {}
  ~Quantity() override;
  explicit constexpr Quantity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quantity(const Quantity& from);
  Quantity(Quantity&& from) noexcept
    : Quantity() {
    *this = ::std::move(from);
  }

  inline Quantity& operator=(const Quantity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quantity& operator=(Quantity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Quantity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quantity* internal_default_instance() {
    return reinterpret_cast<const Quantity*>(
               &_Quantity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Quantity& a, Quantity& b) {
    a.Swap(&b);
  }
  inline void Swap(Quantity* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quantity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quantity* New() const final {
    return new Quantity();
  }

  Quantity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quantity>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Quantity& from);
  void MergeFrom(const Quantity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Quantity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Quantity";
  }
  protected:
  explicit Quantity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 6,
    kNameFieldNumber = 1,
    kUnitFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kGeometryFieldNumber = 4,
    kDimFieldNumber = 5,
  };
  // repeated float values = 6;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string unit = 2;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_MUST_USE_RESULT std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string geometry = 4;
  void clear_geometry();
  const std::string& geometry() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_geometry(ArgT0&& arg0, ArgT... args);
  std::string* mutable_geometry();
  PROTOBUF_MUST_USE_RESULT std::string* release_geometry();
  void set_allocated_geometry(std::string* geometry);
  private:
  const std::string& _internal_geometry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_geometry(const std::string& value);
  std::string* _internal_mutable_geometry();
  public:

  // int32 dim = 5;
  void clear_dim();
  ::PROTOBUF_NAMESPACE_ID::int32 dim() const;
  void set_dim(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dim() const;
  void _internal_set_dim(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:DTCC.Quantity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr geometry_;
  ::PROTOBUF_NAMESPACE_ID::int32 dim_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// -------------------------------------------------------------------

class Raster final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Raster) */ {
 public:
  inline Raster() : Raster(nullptr) {}
  ~Raster() override;
  explicit constexpr Raster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Raster(const Raster& from);
  Raster(Raster&& from) noexcept
    : Raster() {
    *this = ::std::move(from);
  }

  inline Raster& operator=(const Raster& from) {
    CopyFrom(from);
    return *this;
  }
  inline Raster& operator=(Raster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Raster& default_instance() {
    return *internal_default_instance();
  }
  static inline const Raster* internal_default_instance() {
    return reinterpret_cast<const Raster*>(
               &_Raster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Raster& a, Raster& b) {
    a.Swap(&b);
  }
  inline void Swap(Raster* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Raster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Raster* New() const final {
    return new Raster();
  }

  Raster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Raster>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Raster& from);
  void MergeFrom(const Raster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Raster* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DTCC.Raster";
  }
  protected:
  explicit Raster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 6,
    kNameFieldNumber = 1,
    kUnitFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kGridFieldNumber = 4,
    kDimFieldNumber = 5,
  };
  // repeated float values = 6;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string unit = 2;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_MUST_USE_RESULT std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .DTCC.Grid grid = 4;
  bool has_grid() const;
  private:
  bool _internal_has_grid() const;
  public:
  void clear_grid();
  const ::DTCC::Grid& grid() const;
  PROTOBUF_MUST_USE_RESULT ::DTCC::Grid* release_grid();
  ::DTCC::Grid* mutable_grid();
  void set_allocated_grid(::DTCC::Grid* grid);
  private:
  const ::DTCC::Grid& _internal_grid() const;
  ::DTCC::Grid* _internal_mutable_grid();
  public:
  void unsafe_arena_set_allocated_grid(
      ::DTCC::Grid* grid);
  ::DTCC::Grid* unsafe_arena_release_grid();

  // int32 dim = 5;
  void clear_dim();
  ::PROTOBUF_NAMESPACE_ID::int32 dim() const;
  void set_dim(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dim() const;
  void _internal_set_dim(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:DTCC.Raster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::DTCC::Grid* grid_;
  ::PROTOBUF_NAMESPACE_ID::int32 dim_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dtcc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Object

// string id = 1;
inline void Object::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Object::id() const {
  // @@protoc_insertion_point(field_get:DTCC.Object.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Object.id)
}
inline std::string* Object::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.id)
  return _s;
}
inline const std::string& Object::_internal_id() const {
  return id_.Get();
}
inline void Object::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Object::release_id() {
  // @@protoc_insertion_point(field_release:DTCC.Object.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Object::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.id)
}

// string attributes = 2;
inline void Object::clear_attributes() {
  attributes_.ClearToEmpty();
}
inline const std::string& Object::attributes() const {
  // @@protoc_insertion_point(field_get:DTCC.Object.attributes)
  return _internal_attributes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_attributes(ArgT0&& arg0, ArgT... args) {
 
 attributes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Object.attributes)
}
inline std::string* Object::mutable_attributes() {
  std::string* _s = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.attributes)
  return _s;
}
inline const std::string& Object::_internal_attributes() const {
  return attributes_.Get();
}
inline void Object::_internal_set_attributes(const std::string& value) {
  
  attributes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_attributes() {
  
  return attributes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Object::release_attributes() {
  // @@protoc_insertion_point(field_release:DTCC.Object.attributes)
  return attributes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Object::set_allocated_attributes(std::string* attributes) {
  if (attributes != nullptr) {
    
  } else {
    
  }
  attributes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attributes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.attributes)
}

// map<string, .DTCC.Geometry> geometry = 3;
inline int Object::_internal_geometry_size() const {
  return geometry_.size();
}
inline int Object::geometry_size() const {
  return _internal_geometry_size();
}
inline void Object::clear_geometry() {
  geometry_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >&
Object::_internal_geometry() const {
  return geometry_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >&
Object::geometry() const {
  // @@protoc_insertion_point(field_map:DTCC.Object.geometry)
  return _internal_geometry();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >*
Object::_internal_mutable_geometry() {
  return geometry_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::DTCC::Geometry >*
Object::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_map:DTCC.Object.geometry)
  return _internal_mutable_geometry();
}

// repeated .DTCC.Quantity quantities = 4;
inline int Object::_internal_quantities_size() const {
  return quantities_.size();
}
inline int Object::quantities_size() const {
  return _internal_quantities_size();
}
inline void Object::clear_quantities() {
  quantities_.Clear();
}
inline ::DTCC::Quantity* Object::mutable_quantities(int index) {
  // @@protoc_insertion_point(field_mutable:DTCC.Object.quantities)
  return quantities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Quantity >*
Object::mutable_quantities() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Object.quantities)
  return &quantities_;
}
inline const ::DTCC::Quantity& Object::_internal_quantities(int index) const {
  return quantities_.Get(index);
}
inline const ::DTCC::Quantity& Object::quantities(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Object.quantities)
  return _internal_quantities(index);
}
inline ::DTCC::Quantity* Object::_internal_add_quantities() {
  return quantities_.Add();
}
inline ::DTCC::Quantity* Object::add_quantities() {
  ::DTCC::Quantity* _add = _internal_add_quantities();
  // @@protoc_insertion_point(field_add:DTCC.Object.quantities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Quantity >&
Object::quantities() const {
  // @@protoc_insertion_point(field_list:DTCC.Object.quantities)
  return quantities_;
}

// repeated .DTCC.Object children = 5;
inline int Object::_internal_children_size() const {
  return children_.size();
}
inline int Object::children_size() const {
  return _internal_children_size();
}
inline void Object::clear_children() {
  children_.Clear();
}
inline ::DTCC::Object* Object::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:DTCC.Object.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Object >*
Object::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Object.children)
  return &children_;
}
inline const ::DTCC::Object& Object::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::DTCC::Object& Object::children(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Object.children)
  return _internal_children(index);
}
inline ::DTCC::Object* Object::_internal_add_children() {
  return children_.Add();
}
inline ::DTCC::Object* Object::add_children() {
  ::DTCC::Object* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:DTCC.Object.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Object >&
Object::children() const {
  // @@protoc_insertion_point(field_list:DTCC.Object.children)
  return children_;
}

// .DTCC.City city = 6;
inline bool Object::_internal_has_city() const {
  return type_case() == kCity;
}
inline bool Object::has_city() const {
  return _internal_has_city();
}
inline void Object::set_has_city() {
  _oneof_case_[0] = kCity;
}
inline void Object::clear_city() {
  if (_internal_has_city()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.city_;
    }
    clear_has_type();
  }
}
inline ::DTCC::City* Object::release_city() {
  // @@protoc_insertion_point(field_release:DTCC.Object.city)
  if (_internal_has_city()) {
    clear_has_type();
      ::DTCC::City* temp = type_.city_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.city_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::City& Object::_internal_city() const {
  return _internal_has_city()
      ? *type_.city_
      : reinterpret_cast< ::DTCC::City&>(::DTCC::_City_default_instance_);
}
inline const ::DTCC::City& Object::city() const {
  // @@protoc_insertion_point(field_get:DTCC.Object.city)
  return _internal_city();
}
inline ::DTCC::City* Object::unsafe_arena_release_city() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Object.city)
  if (_internal_has_city()) {
    clear_has_type();
    ::DTCC::City* temp = type_.city_;
    type_.city_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Object::unsafe_arena_set_allocated_city(::DTCC::City* city) {
  clear_type();
  if (city) {
    set_has_city();
    type_.city_ = city;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.city)
}
inline ::DTCC::City* Object::_internal_mutable_city() {
  if (!_internal_has_city()) {
    clear_type();
    set_has_city();
    type_.city_ = CreateMaybeMessage< ::DTCC::City >(GetArenaForAllocation());
  }
  return type_.city_;
}
inline ::DTCC::City* Object::mutable_city() {
  ::DTCC::City* _msg = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.city)
  return _msg;
}

// .DTCC.Building building = 7;
inline bool Object::_internal_has_building() const {
  return type_case() == kBuilding;
}
inline bool Object::has_building() const {
  return _internal_has_building();
}
inline void Object::set_has_building() {
  _oneof_case_[0] = kBuilding;
}
inline void Object::clear_building() {
  if (_internal_has_building()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.building_;
    }
    clear_has_type();
  }
}
inline ::DTCC::Building* Object::release_building() {
  // @@protoc_insertion_point(field_release:DTCC.Object.building)
  if (_internal_has_building()) {
    clear_has_type();
      ::DTCC::Building* temp = type_.building_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.building_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::Building& Object::_internal_building() const {
  return _internal_has_building()
      ? *type_.building_
      : reinterpret_cast< ::DTCC::Building&>(::DTCC::_Building_default_instance_);
}
inline const ::DTCC::Building& Object::building() const {
  // @@protoc_insertion_point(field_get:DTCC.Object.building)
  return _internal_building();
}
inline ::DTCC::Building* Object::unsafe_arena_release_building() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Object.building)
  if (_internal_has_building()) {
    clear_has_type();
    ::DTCC::Building* temp = type_.building_;
    type_.building_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Object::unsafe_arena_set_allocated_building(::DTCC::Building* building) {
  clear_type();
  if (building) {
    set_has_building();
    type_.building_ = building;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.building)
}
inline ::DTCC::Building* Object::_internal_mutable_building() {
  if (!_internal_has_building()) {
    clear_type();
    set_has_building();
    type_.building_ = CreateMaybeMessage< ::DTCC::Building >(GetArenaForAllocation());
  }
  return type_.building_;
}
inline ::DTCC::Building* Object::mutable_building() {
  ::DTCC::Building* _msg = _internal_mutable_building();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.building)
  return _msg;
}

// .DTCC.Terrain terrain = 8;
inline bool Object::_internal_has_terrain() const {
  return type_case() == kTerrain;
}
inline bool Object::has_terrain() const {
  return _internal_has_terrain();
}
inline void Object::set_has_terrain() {
  _oneof_case_[0] = kTerrain;
}
inline void Object::clear_terrain() {
  if (_internal_has_terrain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.terrain_;
    }
    clear_has_type();
  }
}
inline ::DTCC::Terrain* Object::release_terrain() {
  // @@protoc_insertion_point(field_release:DTCC.Object.terrain)
  if (_internal_has_terrain()) {
    clear_has_type();
      ::DTCC::Terrain* temp = type_.terrain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.terrain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::Terrain& Object::_internal_terrain() const {
  return _internal_has_terrain()
      ? *type_.terrain_
      : reinterpret_cast< ::DTCC::Terrain&>(::DTCC::_Terrain_default_instance_);
}
inline const ::DTCC::Terrain& Object::terrain() const {
  // @@protoc_insertion_point(field_get:DTCC.Object.terrain)
  return _internal_terrain();
}
inline ::DTCC::Terrain* Object::unsafe_arena_release_terrain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Object.terrain)
  if (_internal_has_terrain()) {
    clear_has_type();
    ::DTCC::Terrain* temp = type_.terrain_;
    type_.terrain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Object::unsafe_arena_set_allocated_terrain(::DTCC::Terrain* terrain) {
  clear_type();
  if (terrain) {
    set_has_terrain();
    type_.terrain_ = terrain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.terrain)
}
inline ::DTCC::Terrain* Object::_internal_mutable_terrain() {
  if (!_internal_has_terrain()) {
    clear_type();
    set_has_terrain();
    type_.terrain_ = CreateMaybeMessage< ::DTCC::Terrain >(GetArenaForAllocation());
  }
  return type_.terrain_;
}
inline ::DTCC::Terrain* Object::mutable_terrain() {
  ::DTCC::Terrain* _msg = _internal_mutable_terrain();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.terrain)
  return _msg;
}

// .DTCC.CityObject city_object = 9;
inline bool Object::_internal_has_city_object() const {
  return type_case() == kCityObject;
}
inline bool Object::has_city_object() const {
  return _internal_has_city_object();
}
inline void Object::set_has_city_object() {
  _oneof_case_[0] = kCityObject;
}
inline void Object::clear_city_object() {
  if (_internal_has_city_object()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.city_object_;
    }
    clear_has_type();
  }
}
inline ::DTCC::CityObject* Object::release_city_object() {
  // @@protoc_insertion_point(field_release:DTCC.Object.city_object)
  if (_internal_has_city_object()) {
    clear_has_type();
      ::DTCC::CityObject* temp = type_.city_object_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.city_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::CityObject& Object::_internal_city_object() const {
  return _internal_has_city_object()
      ? *type_.city_object_
      : reinterpret_cast< ::DTCC::CityObject&>(::DTCC::_CityObject_default_instance_);
}
inline const ::DTCC::CityObject& Object::city_object() const {
  // @@protoc_insertion_point(field_get:DTCC.Object.city_object)
  return _internal_city_object();
}
inline ::DTCC::CityObject* Object::unsafe_arena_release_city_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Object.city_object)
  if (_internal_has_city_object()) {
    clear_has_type();
    ::DTCC::CityObject* temp = type_.city_object_;
    type_.city_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Object::unsafe_arena_set_allocated_city_object(::DTCC::CityObject* city_object) {
  clear_type();
  if (city_object) {
    set_has_city_object();
    type_.city_object_ = city_object;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.city_object)
}
inline ::DTCC::CityObject* Object::_internal_mutable_city_object() {
  if (!_internal_has_city_object()) {
    clear_type();
    set_has_city_object();
    type_.city_object_ = CreateMaybeMessage< ::DTCC::CityObject >(GetArenaForAllocation());
  }
  return type_.city_object_;
}
inline ::DTCC::CityObject* Object::mutable_city_object() {
  ::DTCC::CityObject* _msg = _internal_mutable_city_object();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.city_object)
  return _msg;
}

// .DTCC.BuildingPart building_part = 10;
inline bool Object::_internal_has_building_part() const {
  return type_case() == kBuildingPart;
}
inline bool Object::has_building_part() const {
  return _internal_has_building_part();
}
inline void Object::set_has_building_part() {
  _oneof_case_[0] = kBuildingPart;
}
inline void Object::clear_building_part() {
  if (_internal_has_building_part()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.building_part_;
    }
    clear_has_type();
  }
}
inline ::DTCC::BuildingPart* Object::release_building_part() {
  // @@protoc_insertion_point(field_release:DTCC.Object.building_part)
  if (_internal_has_building_part()) {
    clear_has_type();
      ::DTCC::BuildingPart* temp = type_.building_part_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.building_part_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::BuildingPart& Object::_internal_building_part() const {
  return _internal_has_building_part()
      ? *type_.building_part_
      : reinterpret_cast< ::DTCC::BuildingPart&>(::DTCC::_BuildingPart_default_instance_);
}
inline const ::DTCC::BuildingPart& Object::building_part() const {
  // @@protoc_insertion_point(field_get:DTCC.Object.building_part)
  return _internal_building_part();
}
inline ::DTCC::BuildingPart* Object::unsafe_arena_release_building_part() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Object.building_part)
  if (_internal_has_building_part()) {
    clear_has_type();
    ::DTCC::BuildingPart* temp = type_.building_part_;
    type_.building_part_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Object::unsafe_arena_set_allocated_building_part(::DTCC::BuildingPart* building_part) {
  clear_type();
  if (building_part) {
    set_has_building_part();
    type_.building_part_ = building_part;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.building_part)
}
inline ::DTCC::BuildingPart* Object::_internal_mutable_building_part() {
  if (!_internal_has_building_part()) {
    clear_type();
    set_has_building_part();
    type_.building_part_ = CreateMaybeMessage< ::DTCC::BuildingPart >(GetArenaForAllocation());
  }
  return type_.building_part_;
}
inline ::DTCC::BuildingPart* Object::mutable_building_part() {
  ::DTCC::BuildingPart* _msg = _internal_mutable_building_part();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.building_part)
  return _msg;
}

inline bool Object::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Object::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Object::TypeCase Object::type_case() const {
  return Object::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// City

// -------------------------------------------------------------------

// Building

// -------------------------------------------------------------------

// Terrain

// -------------------------------------------------------------------

// CityObject

// -------------------------------------------------------------------

// BuildingPart

// -------------------------------------------------------------------

// Bounds

// float xmin = 1;
inline void Bounds::clear_xmin() {
  xmin_ = 0;
}
inline float Bounds::_internal_xmin() const {
  return xmin_;
}
inline float Bounds::xmin() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.xmin)
  return _internal_xmin();
}
inline void Bounds::_internal_set_xmin(float value) {
  
  xmin_ = value;
}
inline void Bounds::set_xmin(float value) {
  _internal_set_xmin(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.xmin)
}

// float ymin = 2;
inline void Bounds::clear_ymin() {
  ymin_ = 0;
}
inline float Bounds::_internal_ymin() const {
  return ymin_;
}
inline float Bounds::ymin() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.ymin)
  return _internal_ymin();
}
inline void Bounds::_internal_set_ymin(float value) {
  
  ymin_ = value;
}
inline void Bounds::set_ymin(float value) {
  _internal_set_ymin(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.ymin)
}

// float zmin = 3;
inline void Bounds::clear_zmin() {
  zmin_ = 0;
}
inline float Bounds::_internal_zmin() const {
  return zmin_;
}
inline float Bounds::zmin() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.zmin)
  return _internal_zmin();
}
inline void Bounds::_internal_set_zmin(float value) {
  
  zmin_ = value;
}
inline void Bounds::set_zmin(float value) {
  _internal_set_zmin(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.zmin)
}

// float xmax = 4;
inline void Bounds::clear_xmax() {
  xmax_ = 0;
}
inline float Bounds::_internal_xmax() const {
  return xmax_;
}
inline float Bounds::xmax() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.xmax)
  return _internal_xmax();
}
inline void Bounds::_internal_set_xmax(float value) {
  
  xmax_ = value;
}
inline void Bounds::set_xmax(float value) {
  _internal_set_xmax(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.xmax)
}

// float ymax = 5;
inline void Bounds::clear_ymax() {
  ymax_ = 0;
}
inline float Bounds::_internal_ymax() const {
  return ymax_;
}
inline float Bounds::ymax() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.ymax)
  return _internal_ymax();
}
inline void Bounds::_internal_set_ymax(float value) {
  
  ymax_ = value;
}
inline void Bounds::set_ymax(float value) {
  _internal_set_ymax(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.ymax)
}

// float zmax = 6;
inline void Bounds::clear_zmax() {
  zmax_ = 0;
}
inline float Bounds::_internal_zmax() const {
  return zmax_;
}
inline float Bounds::zmax() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.zmax)
  return _internal_zmax();
}
inline void Bounds::_internal_set_zmax(float value) {
  
  zmax_ = value;
}
inline void Bounds::set_zmax(float value) {
  _internal_set_zmax(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.zmax)
}

// -------------------------------------------------------------------

// Transform

// string srs = 1;
inline void Transform::clear_srs() {
  srs_.ClearToEmpty();
}
inline const std::string& Transform::srs() const {
  // @@protoc_insertion_point(field_get:DTCC.Transform.srs)
  return _internal_srs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transform::set_srs(ArgT0&& arg0, ArgT... args) {
 
 srs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Transform.srs)
}
inline std::string* Transform::mutable_srs() {
  std::string* _s = _internal_mutable_srs();
  // @@protoc_insertion_point(field_mutable:DTCC.Transform.srs)
  return _s;
}
inline const std::string& Transform::_internal_srs() const {
  return srs_.Get();
}
inline void Transform::_internal_set_srs(const std::string& value) {
  
  srs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transform::_internal_mutable_srs() {
  
  return srs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transform::release_srs() {
  // @@protoc_insertion_point(field_release:DTCC.Transform.srs)
  return srs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transform::set_allocated_srs(std::string* srs) {
  if (srs != nullptr) {
    
  } else {
    
  }
  srs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srs,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Transform.srs)
}

// repeated float affine = 2;
inline int Transform::_internal_affine_size() const {
  return affine_.size();
}
inline int Transform::affine_size() const {
  return _internal_affine_size();
}
inline void Transform::clear_affine() {
  affine_.Clear();
}
inline float Transform::_internal_affine(int index) const {
  return affine_.Get(index);
}
inline float Transform::affine(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Transform.affine)
  return _internal_affine(index);
}
inline void Transform::set_affine(int index, float value) {
  affine_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Transform.affine)
}
inline void Transform::_internal_add_affine(float value) {
  affine_.Add(value);
}
inline void Transform::add_affine(float value) {
  _internal_add_affine(value);
  // @@protoc_insertion_point(field_add:DTCC.Transform.affine)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Transform::_internal_affine() const {
  return affine_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Transform::affine() const {
  // @@protoc_insertion_point(field_list:DTCC.Transform.affine)
  return _internal_affine();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Transform::_internal_mutable_affine() {
  return &affine_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Transform::mutable_affine() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Transform.affine)
  return _internal_mutable_affine();
}

// -------------------------------------------------------------------

// LineString

// repeated float vertices = 1;
inline int LineString::_internal_vertices_size() const {
  return vertices_.size();
}
inline int LineString::vertices_size() const {
  return _internal_vertices_size();
}
inline void LineString::clear_vertices() {
  vertices_.Clear();
}
inline float LineString::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline float LineString::vertices(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.LineString.vertices)
  return _internal_vertices(index);
}
inline void LineString::set_vertices(int index, float value) {
  vertices_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.LineString.vertices)
}
inline void LineString::_internal_add_vertices(float value) {
  vertices_.Add(value);
}
inline void LineString::add_vertices(float value) {
  _internal_add_vertices(value);
  // @@protoc_insertion_point(field_add:DTCC.LineString.vertices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
LineString::_internal_vertices() const {
  return vertices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
LineString::vertices() const {
  // @@protoc_insertion_point(field_list:DTCC.LineString.vertices)
  return _internal_vertices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
LineString::_internal_mutable_vertices() {
  return &vertices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
LineString::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.LineString.vertices)
  return _internal_mutable_vertices();
}

// -------------------------------------------------------------------

// Geometry

// .DTCC.Bounds bounds = 1;
inline bool Geometry::_internal_has_bounds() const {
  return this != internal_default_instance() && bounds_ != nullptr;
}
inline bool Geometry::has_bounds() const {
  return _internal_has_bounds();
}
inline void Geometry::clear_bounds() {
  if (GetArenaForAllocation() == nullptr && bounds_ != nullptr) {
    delete bounds_;
  }
  bounds_ = nullptr;
}
inline const ::DTCC::Bounds& Geometry::_internal_bounds() const {
  const ::DTCC::Bounds* p = bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Bounds&>(
      ::DTCC::_Bounds_default_instance_);
}
inline const ::DTCC::Bounds& Geometry::bounds() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.bounds)
  return _internal_bounds();
}
inline void Geometry::unsafe_arena_set_allocated_bounds(
    ::DTCC::Bounds* bounds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bounds_);
  }
  bounds_ = bounds;
  if (bounds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.bounds)
}
inline ::DTCC::Bounds* Geometry::release_bounds() {
  
  ::DTCC::Bounds* temp = bounds_;
  bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DTCC::Bounds* Geometry::unsafe_arena_release_bounds() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.bounds)
  
  ::DTCC::Bounds* temp = bounds_;
  bounds_ = nullptr;
  return temp;
}
inline ::DTCC::Bounds* Geometry::_internal_mutable_bounds() {
  
  if (bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Bounds>(GetArenaForAllocation());
    bounds_ = p;
  }
  return bounds_;
}
inline ::DTCC::Bounds* Geometry::mutable_bounds() {
  ::DTCC::Bounds* _msg = _internal_mutable_bounds();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.bounds)
  return _msg;
}
inline void Geometry::set_allocated_bounds(::DTCC::Bounds* bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bounds_;
  }
  if (bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::Bounds>::GetOwningArena(bounds);
    if (message_arena != submessage_arena) {
      bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounds, submessage_arena);
    }
    
  } else {
    
  }
  bounds_ = bounds;
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.bounds)
}

// .DTCC.Transform transform = 2;
inline bool Geometry::_internal_has_transform() const {
  return this != internal_default_instance() && transform_ != nullptr;
}
inline bool Geometry::has_transform() const {
  return _internal_has_transform();
}
inline void Geometry::clear_transform() {
  if (GetArenaForAllocation() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
}
inline const ::DTCC::Transform& Geometry::_internal_transform() const {
  const ::DTCC::Transform* p = transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Transform&>(
      ::DTCC::_Transform_default_instance_);
}
inline const ::DTCC::Transform& Geometry::transform() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.transform)
  return _internal_transform();
}
inline void Geometry::unsafe_arena_set_allocated_transform(
    ::DTCC::Transform* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_);
  }
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.transform)
}
inline ::DTCC::Transform* Geometry::release_transform() {
  
  ::DTCC::Transform* temp = transform_;
  transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DTCC::Transform* Geometry::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.transform)
  
  ::DTCC::Transform* temp = transform_;
  transform_ = nullptr;
  return temp;
}
inline ::DTCC::Transform* Geometry::_internal_mutable_transform() {
  
  if (transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Transform>(GetArenaForAllocation());
    transform_ = p;
  }
  return transform_;
}
inline ::DTCC::Transform* Geometry::mutable_transform() {
  ::DTCC::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.transform)
  return _msg;
}
inline void Geometry::set_allocated_transform(::DTCC::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::Transform>::GetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:DTCC.Geometry.transform)
}

// .DTCC.Surface surface = 3;
inline bool Geometry::_internal_has_surface() const {
  return type_case() == kSurface;
}
inline bool Geometry::has_surface() const {
  return _internal_has_surface();
}
inline void Geometry::set_has_surface() {
  _oneof_case_[0] = kSurface;
}
inline void Geometry::clear_surface() {
  if (_internal_has_surface()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.surface_;
    }
    clear_has_type();
  }
}
inline ::DTCC::Surface* Geometry::release_surface() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.surface)
  if (_internal_has_surface()) {
    clear_has_type();
      ::DTCC::Surface* temp = type_.surface_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.surface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::Surface& Geometry::_internal_surface() const {
  return _internal_has_surface()
      ? *type_.surface_
      : reinterpret_cast< ::DTCC::Surface&>(::DTCC::_Surface_default_instance_);
}
inline const ::DTCC::Surface& Geometry::surface() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.surface)
  return _internal_surface();
}
inline ::DTCC::Surface* Geometry::unsafe_arena_release_surface() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Geometry.surface)
  if (_internal_has_surface()) {
    clear_has_type();
    ::DTCC::Surface* temp = type_.surface_;
    type_.surface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geometry::unsafe_arena_set_allocated_surface(::DTCC::Surface* surface) {
  clear_type();
  if (surface) {
    set_has_surface();
    type_.surface_ = surface;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.surface)
}
inline ::DTCC::Surface* Geometry::_internal_mutable_surface() {
  if (!_internal_has_surface()) {
    clear_type();
    set_has_surface();
    type_.surface_ = CreateMaybeMessage< ::DTCC::Surface >(GetArenaForAllocation());
  }
  return type_.surface_;
}
inline ::DTCC::Surface* Geometry::mutable_surface() {
  ::DTCC::Surface* _msg = _internal_mutable_surface();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.surface)
  return _msg;
}

// .DTCC.MultiSurface multi_surface = 4;
inline bool Geometry::_internal_has_multi_surface() const {
  return type_case() == kMultiSurface;
}
inline bool Geometry::has_multi_surface() const {
  return _internal_has_multi_surface();
}
inline void Geometry::set_has_multi_surface() {
  _oneof_case_[0] = kMultiSurface;
}
inline void Geometry::clear_multi_surface() {
  if (_internal_has_multi_surface()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.multi_surface_;
    }
    clear_has_type();
  }
}
inline ::DTCC::MultiSurface* Geometry::release_multi_surface() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.multi_surface)
  if (_internal_has_multi_surface()) {
    clear_has_type();
      ::DTCC::MultiSurface* temp = type_.multi_surface_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.multi_surface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::MultiSurface& Geometry::_internal_multi_surface() const {
  return _internal_has_multi_surface()
      ? *type_.multi_surface_
      : reinterpret_cast< ::DTCC::MultiSurface&>(::DTCC::_MultiSurface_default_instance_);
}
inline const ::DTCC::MultiSurface& Geometry::multi_surface() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.multi_surface)
  return _internal_multi_surface();
}
inline ::DTCC::MultiSurface* Geometry::unsafe_arena_release_multi_surface() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Geometry.multi_surface)
  if (_internal_has_multi_surface()) {
    clear_has_type();
    ::DTCC::MultiSurface* temp = type_.multi_surface_;
    type_.multi_surface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geometry::unsafe_arena_set_allocated_multi_surface(::DTCC::MultiSurface* multi_surface) {
  clear_type();
  if (multi_surface) {
    set_has_multi_surface();
    type_.multi_surface_ = multi_surface;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.multi_surface)
}
inline ::DTCC::MultiSurface* Geometry::_internal_mutable_multi_surface() {
  if (!_internal_has_multi_surface()) {
    clear_type();
    set_has_multi_surface();
    type_.multi_surface_ = CreateMaybeMessage< ::DTCC::MultiSurface >(GetArenaForAllocation());
  }
  return type_.multi_surface_;
}
inline ::DTCC::MultiSurface* Geometry::mutable_multi_surface() {
  ::DTCC::MultiSurface* _msg = _internal_mutable_multi_surface();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.multi_surface)
  return _msg;
}

// .DTCC.PointCloud point_cloud = 5;
inline bool Geometry::_internal_has_point_cloud() const {
  return type_case() == kPointCloud;
}
inline bool Geometry::has_point_cloud() const {
  return _internal_has_point_cloud();
}
inline void Geometry::set_has_point_cloud() {
  _oneof_case_[0] = kPointCloud;
}
inline void Geometry::clear_point_cloud() {
  if (_internal_has_point_cloud()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.point_cloud_;
    }
    clear_has_type();
  }
}
inline ::DTCC::PointCloud* Geometry::release_point_cloud() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.point_cloud)
  if (_internal_has_point_cloud()) {
    clear_has_type();
      ::DTCC::PointCloud* temp = type_.point_cloud_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.point_cloud_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::PointCloud& Geometry::_internal_point_cloud() const {
  return _internal_has_point_cloud()
      ? *type_.point_cloud_
      : reinterpret_cast< ::DTCC::PointCloud&>(::DTCC::_PointCloud_default_instance_);
}
inline const ::DTCC::PointCloud& Geometry::point_cloud() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.point_cloud)
  return _internal_point_cloud();
}
inline ::DTCC::PointCloud* Geometry::unsafe_arena_release_point_cloud() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Geometry.point_cloud)
  if (_internal_has_point_cloud()) {
    clear_has_type();
    ::DTCC::PointCloud* temp = type_.point_cloud_;
    type_.point_cloud_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geometry::unsafe_arena_set_allocated_point_cloud(::DTCC::PointCloud* point_cloud) {
  clear_type();
  if (point_cloud) {
    set_has_point_cloud();
    type_.point_cloud_ = point_cloud;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.point_cloud)
}
inline ::DTCC::PointCloud* Geometry::_internal_mutable_point_cloud() {
  if (!_internal_has_point_cloud()) {
    clear_type();
    set_has_point_cloud();
    type_.point_cloud_ = CreateMaybeMessage< ::DTCC::PointCloud >(GetArenaForAllocation());
  }
  return type_.point_cloud_;
}
inline ::DTCC::PointCloud* Geometry::mutable_point_cloud() {
  ::DTCC::PointCloud* _msg = _internal_mutable_point_cloud();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.point_cloud)
  return _msg;
}

// .DTCC.Mesh mesh = 6;
inline bool Geometry::_internal_has_mesh() const {
  return type_case() == kMesh;
}
inline bool Geometry::has_mesh() const {
  return _internal_has_mesh();
}
inline void Geometry::set_has_mesh() {
  _oneof_case_[0] = kMesh;
}
inline void Geometry::clear_mesh() {
  if (_internal_has_mesh()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.mesh_;
    }
    clear_has_type();
  }
}
inline ::DTCC::Mesh* Geometry::release_mesh() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.mesh)
  if (_internal_has_mesh()) {
    clear_has_type();
      ::DTCC::Mesh* temp = type_.mesh_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.mesh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::Mesh& Geometry::_internal_mesh() const {
  return _internal_has_mesh()
      ? *type_.mesh_
      : reinterpret_cast< ::DTCC::Mesh&>(::DTCC::_Mesh_default_instance_);
}
inline const ::DTCC::Mesh& Geometry::mesh() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.mesh)
  return _internal_mesh();
}
inline ::DTCC::Mesh* Geometry::unsafe_arena_release_mesh() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Geometry.mesh)
  if (_internal_has_mesh()) {
    clear_has_type();
    ::DTCC::Mesh* temp = type_.mesh_;
    type_.mesh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geometry::unsafe_arena_set_allocated_mesh(::DTCC::Mesh* mesh) {
  clear_type();
  if (mesh) {
    set_has_mesh();
    type_.mesh_ = mesh;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.mesh)
}
inline ::DTCC::Mesh* Geometry::_internal_mutable_mesh() {
  if (!_internal_has_mesh()) {
    clear_type();
    set_has_mesh();
    type_.mesh_ = CreateMaybeMessage< ::DTCC::Mesh >(GetArenaForAllocation());
  }
  return type_.mesh_;
}
inline ::DTCC::Mesh* Geometry::mutable_mesh() {
  ::DTCC::Mesh* _msg = _internal_mutable_mesh();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.mesh)
  return _msg;
}

// .DTCC.VolumeMesh volume_mesh = 7;
inline bool Geometry::_internal_has_volume_mesh() const {
  return type_case() == kVolumeMesh;
}
inline bool Geometry::has_volume_mesh() const {
  return _internal_has_volume_mesh();
}
inline void Geometry::set_has_volume_mesh() {
  _oneof_case_[0] = kVolumeMesh;
}
inline void Geometry::clear_volume_mesh() {
  if (_internal_has_volume_mesh()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.volume_mesh_;
    }
    clear_has_type();
  }
}
inline ::DTCC::VolumeMesh* Geometry::release_volume_mesh() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.volume_mesh)
  if (_internal_has_volume_mesh()) {
    clear_has_type();
      ::DTCC::VolumeMesh* temp = type_.volume_mesh_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.volume_mesh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::VolumeMesh& Geometry::_internal_volume_mesh() const {
  return _internal_has_volume_mesh()
      ? *type_.volume_mesh_
      : reinterpret_cast< ::DTCC::VolumeMesh&>(::DTCC::_VolumeMesh_default_instance_);
}
inline const ::DTCC::VolumeMesh& Geometry::volume_mesh() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.volume_mesh)
  return _internal_volume_mesh();
}
inline ::DTCC::VolumeMesh* Geometry::unsafe_arena_release_volume_mesh() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Geometry.volume_mesh)
  if (_internal_has_volume_mesh()) {
    clear_has_type();
    ::DTCC::VolumeMesh* temp = type_.volume_mesh_;
    type_.volume_mesh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geometry::unsafe_arena_set_allocated_volume_mesh(::DTCC::VolumeMesh* volume_mesh) {
  clear_type();
  if (volume_mesh) {
    set_has_volume_mesh();
    type_.volume_mesh_ = volume_mesh;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.volume_mesh)
}
inline ::DTCC::VolumeMesh* Geometry::_internal_mutable_volume_mesh() {
  if (!_internal_has_volume_mesh()) {
    clear_type();
    set_has_volume_mesh();
    type_.volume_mesh_ = CreateMaybeMessage< ::DTCC::VolumeMesh >(GetArenaForAllocation());
  }
  return type_.volume_mesh_;
}
inline ::DTCC::VolumeMesh* Geometry::mutable_volume_mesh() {
  ::DTCC::VolumeMesh* _msg = _internal_mutable_volume_mesh();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.volume_mesh)
  return _msg;
}

// .DTCC.Grid grid = 8;
inline bool Geometry::_internal_has_grid() const {
  return type_case() == kGrid;
}
inline bool Geometry::has_grid() const {
  return _internal_has_grid();
}
inline void Geometry::set_has_grid() {
  _oneof_case_[0] = kGrid;
}
inline void Geometry::clear_grid() {
  if (_internal_has_grid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.grid_;
    }
    clear_has_type();
  }
}
inline ::DTCC::Grid* Geometry::release_grid() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.grid)
  if (_internal_has_grid()) {
    clear_has_type();
      ::DTCC::Grid* temp = type_.grid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.grid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::Grid& Geometry::_internal_grid() const {
  return _internal_has_grid()
      ? *type_.grid_
      : reinterpret_cast< ::DTCC::Grid&>(::DTCC::_Grid_default_instance_);
}
inline const ::DTCC::Grid& Geometry::grid() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.grid)
  return _internal_grid();
}
inline ::DTCC::Grid* Geometry::unsafe_arena_release_grid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Geometry.grid)
  if (_internal_has_grid()) {
    clear_has_type();
    ::DTCC::Grid* temp = type_.grid_;
    type_.grid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geometry::unsafe_arena_set_allocated_grid(::DTCC::Grid* grid) {
  clear_type();
  if (grid) {
    set_has_grid();
    type_.grid_ = grid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.grid)
}
inline ::DTCC::Grid* Geometry::_internal_mutable_grid() {
  if (!_internal_has_grid()) {
    clear_type();
    set_has_grid();
    type_.grid_ = CreateMaybeMessage< ::DTCC::Grid >(GetArenaForAllocation());
  }
  return type_.grid_;
}
inline ::DTCC::Grid* Geometry::mutable_grid() {
  ::DTCC::Grid* _msg = _internal_mutable_grid();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.grid)
  return _msg;
}

// .DTCC.VolumeGrid volume_grid = 9;
inline bool Geometry::_internal_has_volume_grid() const {
  return type_case() == kVolumeGrid;
}
inline bool Geometry::has_volume_grid() const {
  return _internal_has_volume_grid();
}
inline void Geometry::set_has_volume_grid() {
  _oneof_case_[0] = kVolumeGrid;
}
inline void Geometry::clear_volume_grid() {
  if (_internal_has_volume_grid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.volume_grid_;
    }
    clear_has_type();
  }
}
inline ::DTCC::VolumeGrid* Geometry::release_volume_grid() {
  // @@protoc_insertion_point(field_release:DTCC.Geometry.volume_grid)
  if (_internal_has_volume_grid()) {
    clear_has_type();
      ::DTCC::VolumeGrid* temp = type_.volume_grid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.volume_grid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DTCC::VolumeGrid& Geometry::_internal_volume_grid() const {
  return _internal_has_volume_grid()
      ? *type_.volume_grid_
      : reinterpret_cast< ::DTCC::VolumeGrid&>(::DTCC::_VolumeGrid_default_instance_);
}
inline const ::DTCC::VolumeGrid& Geometry::volume_grid() const {
  // @@protoc_insertion_point(field_get:DTCC.Geometry.volume_grid)
  return _internal_volume_grid();
}
inline ::DTCC::VolumeGrid* Geometry::unsafe_arena_release_volume_grid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DTCC.Geometry.volume_grid)
  if (_internal_has_volume_grid()) {
    clear_has_type();
    ::DTCC::VolumeGrid* temp = type_.volume_grid_;
    type_.volume_grid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Geometry::unsafe_arena_set_allocated_volume_grid(::DTCC::VolumeGrid* volume_grid) {
  clear_type();
  if (volume_grid) {
    set_has_volume_grid();
    type_.volume_grid_ = volume_grid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Geometry.volume_grid)
}
inline ::DTCC::VolumeGrid* Geometry::_internal_mutable_volume_grid() {
  if (!_internal_has_volume_grid()) {
    clear_type();
    set_has_volume_grid();
    type_.volume_grid_ = CreateMaybeMessage< ::DTCC::VolumeGrid >(GetArenaForAllocation());
  }
  return type_.volume_grid_;
}
inline ::DTCC::VolumeGrid* Geometry::mutable_volume_grid() {
  ::DTCC::VolumeGrid* _msg = _internal_mutable_volume_grid();
  // @@protoc_insertion_point(field_mutable:DTCC.Geometry.volume_grid)
  return _msg;
}

inline bool Geometry::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Geometry::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Geometry::TypeCase Geometry::type_case() const {
  return Geometry::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Surface

// repeated float vertices = 1;
inline int Surface::_internal_vertices_size() const {
  return vertices_.size();
}
inline int Surface::vertices_size() const {
  return _internal_vertices_size();
}
inline void Surface::clear_vertices() {
  vertices_.Clear();
}
inline float Surface::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline float Surface::vertices(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Surface.vertices)
  return _internal_vertices(index);
}
inline void Surface::set_vertices(int index, float value) {
  vertices_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Surface.vertices)
}
inline void Surface::_internal_add_vertices(float value) {
  vertices_.Add(value);
}
inline void Surface::add_vertices(float value) {
  _internal_add_vertices(value);
  // @@protoc_insertion_point(field_add:DTCC.Surface.vertices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Surface::_internal_vertices() const {
  return vertices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Surface::vertices() const {
  // @@protoc_insertion_point(field_list:DTCC.Surface.vertices)
  return _internal_vertices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Surface::_internal_mutable_vertices() {
  return &vertices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Surface::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Surface.vertices)
  return _internal_mutable_vertices();
}

// repeated float normal = 2;
inline int Surface::_internal_normal_size() const {
  return normal_.size();
}
inline int Surface::normal_size() const {
  return _internal_normal_size();
}
inline void Surface::clear_normal() {
  normal_.Clear();
}
inline float Surface::_internal_normal(int index) const {
  return normal_.Get(index);
}
inline float Surface::normal(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Surface.normal)
  return _internal_normal(index);
}
inline void Surface::set_normal(int index, float value) {
  normal_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Surface.normal)
}
inline void Surface::_internal_add_normal(float value) {
  normal_.Add(value);
}
inline void Surface::add_normal(float value) {
  _internal_add_normal(value);
  // @@protoc_insertion_point(field_add:DTCC.Surface.normal)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Surface::_internal_normal() const {
  return normal_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Surface::normal() const {
  // @@protoc_insertion_point(field_list:DTCC.Surface.normal)
  return _internal_normal();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Surface::_internal_mutable_normal() {
  return &normal_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Surface::mutable_normal() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Surface.normal)
  return _internal_mutable_normal();
}

// repeated .DTCC.LineString holes = 3;
inline int Surface::_internal_holes_size() const {
  return holes_.size();
}
inline int Surface::holes_size() const {
  return _internal_holes_size();
}
inline void Surface::clear_holes() {
  holes_.Clear();
}
inline ::DTCC::LineString* Surface::mutable_holes(int index) {
  // @@protoc_insertion_point(field_mutable:DTCC.Surface.holes)
  return holes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::LineString >*
Surface::mutable_holes() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Surface.holes)
  return &holes_;
}
inline const ::DTCC::LineString& Surface::_internal_holes(int index) const {
  return holes_.Get(index);
}
inline const ::DTCC::LineString& Surface::holes(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Surface.holes)
  return _internal_holes(index);
}
inline ::DTCC::LineString* Surface::_internal_add_holes() {
  return holes_.Add();
}
inline ::DTCC::LineString* Surface::add_holes() {
  ::DTCC::LineString* _add = _internal_add_holes();
  // @@protoc_insertion_point(field_add:DTCC.Surface.holes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::LineString >&
Surface::holes() const {
  // @@protoc_insertion_point(field_list:DTCC.Surface.holes)
  return holes_;
}

// -------------------------------------------------------------------

// MultiSurface

// repeated .DTCC.Surface surfaces = 1;
inline int MultiSurface::_internal_surfaces_size() const {
  return surfaces_.size();
}
inline int MultiSurface::surfaces_size() const {
  return _internal_surfaces_size();
}
inline void MultiSurface::clear_surfaces() {
  surfaces_.Clear();
}
inline ::DTCC::Surface* MultiSurface::mutable_surfaces(int index) {
  // @@protoc_insertion_point(field_mutable:DTCC.MultiSurface.surfaces)
  return surfaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Surface >*
MultiSurface::mutable_surfaces() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.MultiSurface.surfaces)
  return &surfaces_;
}
inline const ::DTCC::Surface& MultiSurface::_internal_surfaces(int index) const {
  return surfaces_.Get(index);
}
inline const ::DTCC::Surface& MultiSurface::surfaces(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.MultiSurface.surfaces)
  return _internal_surfaces(index);
}
inline ::DTCC::Surface* MultiSurface::_internal_add_surfaces() {
  return surfaces_.Add();
}
inline ::DTCC::Surface* MultiSurface::add_surfaces() {
  ::DTCC::Surface* _add = _internal_add_surfaces();
  // @@protoc_insertion_point(field_add:DTCC.MultiSurface.surfaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DTCC::Surface >&
MultiSurface::surfaces() const {
  // @@protoc_insertion_point(field_list:DTCC.MultiSurface.surfaces)
  return surfaces_;
}

// -------------------------------------------------------------------

// PointCloud

// repeated float points = 1;
inline int PointCloud::_internal_points_size() const {
  return points_.size();
}
inline int PointCloud::points_size() const {
  return _internal_points_size();
}
inline void PointCloud::clear_points() {
  points_.Clear();
}
inline float PointCloud::_internal_points(int index) const {
  return points_.Get(index);
}
inline float PointCloud::points(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.points)
  return _internal_points(index);
}
inline void PointCloud::set_points(int index, float value) {
  points_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.points)
}
inline void PointCloud::_internal_add_points(float value) {
  points_.Add(value);
}
inline void PointCloud::add_points(float value) {
  _internal_add_points(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.points)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PointCloud::_internal_points() const {
  return points_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PointCloud::points() const {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.points)
  return _internal_points();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PointCloud::_internal_mutable_points() {
  return &points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PointCloud::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.points)
  return _internal_mutable_points();
}

// repeated uint32 classification = 2;
inline int PointCloud::_internal_classification_size() const {
  return classification_.size();
}
inline int PointCloud::classification_size() const {
  return _internal_classification_size();
}
inline void PointCloud::clear_classification() {
  classification_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PointCloud::_internal_classification(int index) const {
  return classification_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PointCloud::classification(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.classification)
  return _internal_classification(index);
}
inline void PointCloud::set_classification(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  classification_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.classification)
}
inline void PointCloud::_internal_add_classification(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  classification_.Add(value);
}
inline void PointCloud::add_classification(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_classification(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.classification)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PointCloud::_internal_classification() const {
  return classification_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PointCloud::classification() const {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.classification)
  return _internal_classification();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PointCloud::_internal_mutable_classification() {
  return &classification_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PointCloud::mutable_classification() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.classification)
  return _internal_mutable_classification();
}

// repeated uint32 intensity = 3;
inline int PointCloud::_internal_intensity_size() const {
  return intensity_.size();
}
inline int PointCloud::intensity_size() const {
  return _internal_intensity_size();
}
inline void PointCloud::clear_intensity() {
  intensity_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PointCloud::_internal_intensity(int index) const {
  return intensity_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PointCloud::intensity(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.intensity)
  return _internal_intensity(index);
}
inline void PointCloud::set_intensity(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  intensity_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.intensity)
}
inline void PointCloud::_internal_add_intensity(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  intensity_.Add(value);
}
inline void PointCloud::add_intensity(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_intensity(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.intensity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PointCloud::_internal_intensity() const {
  return intensity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PointCloud::intensity() const {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.intensity)
  return _internal_intensity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PointCloud::_internal_mutable_intensity() {
  return &intensity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PointCloud::mutable_intensity() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.intensity)
  return _internal_mutable_intensity();
}

// repeated uint32 return_number = 4;
inline int PointCloud::_internal_return_number_size() const {
  return return_number_.size();
}
inline int PointCloud::return_number_size() const {
  return _internal_return_number_size();
}
inline void PointCloud::clear_return_number() {
  return_number_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PointCloud::_internal_return_number(int index) const {
  return return_number_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PointCloud::return_number(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.return_number)
  return _internal_return_number(index);
}
inline void PointCloud::set_return_number(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  return_number_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.return_number)
}
inline void PointCloud::_internal_add_return_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  return_number_.Add(value);
}
inline void PointCloud::add_return_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_return_number(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.return_number)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PointCloud::_internal_return_number() const {
  return return_number_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PointCloud::return_number() const {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.return_number)
  return _internal_return_number();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PointCloud::_internal_mutable_return_number() {
  return &return_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PointCloud::mutable_return_number() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.return_number)
  return _internal_mutable_return_number();
}

// repeated uint32 num_returns = 5;
inline int PointCloud::_internal_num_returns_size() const {
  return num_returns_.size();
}
inline int PointCloud::num_returns_size() const {
  return _internal_num_returns_size();
}
inline void PointCloud::clear_num_returns() {
  num_returns_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PointCloud::_internal_num_returns(int index) const {
  return num_returns_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PointCloud::num_returns(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.num_returns)
  return _internal_num_returns(index);
}
inline void PointCloud::set_num_returns(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  num_returns_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.num_returns)
}
inline void PointCloud::_internal_add_num_returns(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  num_returns_.Add(value);
}
inline void PointCloud::add_num_returns(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_num_returns(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.num_returns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PointCloud::_internal_num_returns() const {
  return num_returns_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PointCloud::num_returns() const {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.num_returns)
  return _internal_num_returns();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PointCloud::_internal_mutable_num_returns() {
  return &num_returns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PointCloud::mutable_num_returns() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.num_returns)
  return _internal_mutable_num_returns();
}

// -------------------------------------------------------------------

// Mesh

// repeated float vertices = 1;
inline int Mesh::_internal_vertices_size() const {
  return vertices_.size();
}
inline int Mesh::vertices_size() const {
  return _internal_vertices_size();
}
inline void Mesh::clear_vertices() {
  vertices_.Clear();
}
inline float Mesh::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline float Mesh::vertices(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Mesh.vertices)
  return _internal_vertices(index);
}
inline void Mesh::set_vertices(int index, float value) {
  vertices_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Mesh.vertices)
}
inline void Mesh::_internal_add_vertices(float value) {
  vertices_.Add(value);
}
inline void Mesh::add_vertices(float value) {
  _internal_add_vertices(value);
  // @@protoc_insertion_point(field_add:DTCC.Mesh.vertices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Mesh::_internal_vertices() const {
  return vertices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Mesh::vertices() const {
  // @@protoc_insertion_point(field_list:DTCC.Mesh.vertices)
  return _internal_vertices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Mesh::_internal_mutable_vertices() {
  return &vertices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Mesh::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Mesh.vertices)
  return _internal_mutable_vertices();
}

// repeated uint32 faces = 2;
inline int Mesh::_internal_faces_size() const {
  return faces_.size();
}
inline int Mesh::faces_size() const {
  return _internal_faces_size();
}
inline void Mesh::clear_faces() {
  faces_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Mesh::_internal_faces(int index) const {
  return faces_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Mesh::faces(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Mesh.faces)
  return _internal_faces(index);
}
inline void Mesh::set_faces(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  faces_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Mesh.faces)
}
inline void Mesh::_internal_add_faces(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  faces_.Add(value);
}
inline void Mesh::add_faces(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_faces(value);
  // @@protoc_insertion_point(field_add:DTCC.Mesh.faces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Mesh::_internal_faces() const {
  return faces_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Mesh::faces() const {
  // @@protoc_insertion_point(field_list:DTCC.Mesh.faces)
  return _internal_faces();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Mesh::_internal_mutable_faces() {
  return &faces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Mesh::mutable_faces() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Mesh.faces)
  return _internal_mutable_faces();
}

// -------------------------------------------------------------------

// VolumeMesh

// repeated float vertices = 1;
inline int VolumeMesh::_internal_vertices_size() const {
  return vertices_.size();
}
inline int VolumeMesh::vertices_size() const {
  return _internal_vertices_size();
}
inline void VolumeMesh::clear_vertices() {
  vertices_.Clear();
}
inline float VolumeMesh::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline float VolumeMesh::vertices(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeMesh.vertices)
  return _internal_vertices(index);
}
inline void VolumeMesh::set_vertices(int index, float value) {
  vertices_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeMesh.vertices)
}
inline void VolumeMesh::_internal_add_vertices(float value) {
  vertices_.Add(value);
}
inline void VolumeMesh::add_vertices(float value) {
  _internal_add_vertices(value);
  // @@protoc_insertion_point(field_add:DTCC.VolumeMesh.vertices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VolumeMesh::_internal_vertices() const {
  return vertices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VolumeMesh::vertices() const {
  // @@protoc_insertion_point(field_list:DTCC.VolumeMesh.vertices)
  return _internal_vertices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VolumeMesh::_internal_mutable_vertices() {
  return &vertices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VolumeMesh::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.VolumeMesh.vertices)
  return _internal_mutable_vertices();
}

// repeated uint32 cells = 2;
inline int VolumeMesh::_internal_cells_size() const {
  return cells_.size();
}
inline int VolumeMesh::cells_size() const {
  return _internal_cells_size();
}
inline void VolumeMesh::clear_cells() {
  cells_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VolumeMesh::_internal_cells(int index) const {
  return cells_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VolumeMesh::cells(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeMesh.cells)
  return _internal_cells(index);
}
inline void VolumeMesh::set_cells(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  cells_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeMesh.cells)
}
inline void VolumeMesh::_internal_add_cells(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  cells_.Add(value);
}
inline void VolumeMesh::add_cells(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_cells(value);
  // @@protoc_insertion_point(field_add:DTCC.VolumeMesh.cells)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
VolumeMesh::_internal_cells() const {
  return cells_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
VolumeMesh::cells() const {
  // @@protoc_insertion_point(field_list:DTCC.VolumeMesh.cells)
  return _internal_cells();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
VolumeMesh::_internal_mutable_cells() {
  return &cells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
VolumeMesh::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.VolumeMesh.cells)
  return _internal_mutable_cells();
}

// -------------------------------------------------------------------

// Grid

// int32 width = 1;
inline void Grid::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Grid::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Grid::width() const {
  // @@protoc_insertion_point(field_get:DTCC.Grid.width)
  return _internal_width();
}
inline void Grid::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void Grid::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:DTCC.Grid.width)
}

// int32 height = 2;
inline void Grid::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Grid::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Grid::height() const {
  // @@protoc_insertion_point(field_get:DTCC.Grid.height)
  return _internal_height();
}
inline void Grid::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void Grid::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:DTCC.Grid.height)
}

// float xstep = 3;
inline void Grid::clear_xstep() {
  xstep_ = 0;
}
inline float Grid::_internal_xstep() const {
  return xstep_;
}
inline float Grid::xstep() const {
  // @@protoc_insertion_point(field_get:DTCC.Grid.xstep)
  return _internal_xstep();
}
inline void Grid::_internal_set_xstep(float value) {
  
  xstep_ = value;
}
inline void Grid::set_xstep(float value) {
  _internal_set_xstep(value);
  // @@protoc_insertion_point(field_set:DTCC.Grid.xstep)
}

// float ystep = 4;
inline void Grid::clear_ystep() {
  ystep_ = 0;
}
inline float Grid::_internal_ystep() const {
  return ystep_;
}
inline float Grid::ystep() const {
  // @@protoc_insertion_point(field_get:DTCC.Grid.ystep)
  return _internal_ystep();
}
inline void Grid::_internal_set_ystep(float value) {
  
  ystep_ = value;
}
inline void Grid::set_ystep(float value) {
  _internal_set_ystep(value);
  // @@protoc_insertion_point(field_set:DTCC.Grid.ystep)
}

// -------------------------------------------------------------------

// VolumeGrid

// int32 width = 1;
inline void VolumeGrid::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VolumeGrid::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VolumeGrid::width() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.width)
  return _internal_width();
}
inline void VolumeGrid::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void VolumeGrid::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.width)
}

// int32 height = 2;
inline void VolumeGrid::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VolumeGrid::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VolumeGrid::height() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.height)
  return _internal_height();
}
inline void VolumeGrid::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void VolumeGrid::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.height)
}

// int32 depth = 3;
inline void VolumeGrid::clear_depth() {
  depth_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VolumeGrid::_internal_depth() const {
  return depth_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VolumeGrid::depth() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.depth)
  return _internal_depth();
}
inline void VolumeGrid::_internal_set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  depth_ = value;
}
inline void VolumeGrid::set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.depth)
}

// float xstep = 4;
inline void VolumeGrid::clear_xstep() {
  xstep_ = 0;
}
inline float VolumeGrid::_internal_xstep() const {
  return xstep_;
}
inline float VolumeGrid::xstep() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.xstep)
  return _internal_xstep();
}
inline void VolumeGrid::_internal_set_xstep(float value) {
  
  xstep_ = value;
}
inline void VolumeGrid::set_xstep(float value) {
  _internal_set_xstep(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.xstep)
}

// float ystep = 5;
inline void VolumeGrid::clear_ystep() {
  ystep_ = 0;
}
inline float VolumeGrid::_internal_ystep() const {
  return ystep_;
}
inline float VolumeGrid::ystep() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.ystep)
  return _internal_ystep();
}
inline void VolumeGrid::_internal_set_ystep(float value) {
  
  ystep_ = value;
}
inline void VolumeGrid::set_ystep(float value) {
  _internal_set_ystep(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.ystep)
}

// float zstep = 6;
inline void VolumeGrid::clear_zstep() {
  zstep_ = 0;
}
inline float VolumeGrid::_internal_zstep() const {
  return zstep_;
}
inline float VolumeGrid::zstep() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.zstep)
  return _internal_zstep();
}
inline void VolumeGrid::_internal_set_zstep(float value) {
  
  zstep_ = value;
}
inline void VolumeGrid::set_zstep(float value) {
  _internal_set_zstep(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.zstep)
}

// -------------------------------------------------------------------

// Quantity

// string name = 1;
inline void Quantity::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Quantity::name() const {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Quantity::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Quantity.name)
}
inline std::string* Quantity::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DTCC.Quantity.name)
  return _s;
}
inline const std::string& Quantity::_internal_name() const {
  return name_.Get();
}
inline void Quantity::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Quantity::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Quantity::release_name() {
  // @@protoc_insertion_point(field_release:DTCC.Quantity.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Quantity::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Quantity.name)
}

// string unit = 2;
inline void Quantity::clear_unit() {
  unit_.ClearToEmpty();
}
inline const std::string& Quantity::unit() const {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Quantity::set_unit(ArgT0&& arg0, ArgT... args) {
 
 unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Quantity.unit)
}
inline std::string* Quantity::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:DTCC.Quantity.unit)
  return _s;
}
inline const std::string& Quantity::_internal_unit() const {
  return unit_.Get();
}
inline void Quantity::_internal_set_unit(const std::string& value) {
  
  unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Quantity::_internal_mutable_unit() {
  
  return unit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Quantity::release_unit() {
  // @@protoc_insertion_point(field_release:DTCC.Quantity.unit)
  return unit_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Quantity::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  unit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unit,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Quantity.unit)
}

// string description = 3;
inline void Quantity::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Quantity::description() const {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Quantity::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Quantity.description)
}
inline std::string* Quantity::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:DTCC.Quantity.description)
  return _s;
}
inline const std::string& Quantity::_internal_description() const {
  return description_.Get();
}
inline void Quantity::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Quantity::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Quantity::release_description() {
  // @@protoc_insertion_point(field_release:DTCC.Quantity.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Quantity::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Quantity.description)
}

// string geometry = 4;
inline void Quantity::clear_geometry() {
  geometry_.ClearToEmpty();
}
inline const std::string& Quantity::geometry() const {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.geometry)
  return _internal_geometry();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Quantity::set_geometry(ArgT0&& arg0, ArgT... args) {
 
 geometry_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Quantity.geometry)
}
inline std::string* Quantity::mutable_geometry() {
  std::string* _s = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:DTCC.Quantity.geometry)
  return _s;
}
inline const std::string& Quantity::_internal_geometry() const {
  return geometry_.Get();
}
inline void Quantity::_internal_set_geometry(const std::string& value) {
  
  geometry_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Quantity::_internal_mutable_geometry() {
  
  return geometry_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Quantity::release_geometry() {
  // @@protoc_insertion_point(field_release:DTCC.Quantity.geometry)
  return geometry_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Quantity::set_allocated_geometry(std::string* geometry) {
  if (geometry != nullptr) {
    
  } else {
    
  }
  geometry_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), geometry,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Quantity.geometry)
}

// int32 dim = 5;
inline void Quantity::clear_dim() {
  dim_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Quantity::_internal_dim() const {
  return dim_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Quantity::dim() const {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.dim)
  return _internal_dim();
}
inline void Quantity::_internal_set_dim(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dim_ = value;
}
inline void Quantity::set_dim(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dim(value);
  // @@protoc_insertion_point(field_set:DTCC.Quantity.dim)
}

// repeated float values = 6;
inline int Quantity::_internal_values_size() const {
  return values_.size();
}
inline int Quantity::values_size() const {
  return _internal_values_size();
}
inline void Quantity::clear_values() {
  values_.Clear();
}
inline float Quantity::_internal_values(int index) const {
  return values_.Get(index);
}
inline float Quantity::values(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.values)
  return _internal_values(index);
}
inline void Quantity::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Quantity.values)
}
inline void Quantity::_internal_add_values(float value) {
  values_.Add(value);
}
inline void Quantity::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:DTCC.Quantity.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Quantity::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Quantity::values() const {
  // @@protoc_insertion_point(field_list:DTCC.Quantity.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Quantity::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Quantity::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Quantity.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Raster

// string name = 1;
inline void Raster::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Raster::name() const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Raster::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Raster.name)
}
inline std::string* Raster::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DTCC.Raster.name)
  return _s;
}
inline const std::string& Raster::_internal_name() const {
  return name_.Get();
}
inline void Raster::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Raster::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Raster::release_name() {
  // @@protoc_insertion_point(field_release:DTCC.Raster.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Raster::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Raster.name)
}

// string unit = 2;
inline void Raster::clear_unit() {
  unit_.ClearToEmpty();
}
inline const std::string& Raster::unit() const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Raster::set_unit(ArgT0&& arg0, ArgT... args) {
 
 unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Raster.unit)
}
inline std::string* Raster::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:DTCC.Raster.unit)
  return _s;
}
inline const std::string& Raster::_internal_unit() const {
  return unit_.Get();
}
inline void Raster::_internal_set_unit(const std::string& value) {
  
  unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Raster::_internal_mutable_unit() {
  
  return unit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Raster::release_unit() {
  // @@protoc_insertion_point(field_release:DTCC.Raster.unit)
  return unit_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Raster::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  unit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unit,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Raster.unit)
}

// string description = 3;
inline void Raster::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Raster::description() const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Raster::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DTCC.Raster.description)
}
inline std::string* Raster::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:DTCC.Raster.description)
  return _s;
}
inline const std::string& Raster::_internal_description() const {
  return description_.Get();
}
inline void Raster::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Raster::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Raster::release_description() {
  // @@protoc_insertion_point(field_release:DTCC.Raster.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Raster::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DTCC.Raster.description)
}

// .DTCC.Grid grid = 4;
inline bool Raster::_internal_has_grid() const {
  return this != internal_default_instance() && grid_ != nullptr;
}
inline bool Raster::has_grid() const {
  return _internal_has_grid();
}
inline void Raster::clear_grid() {
  if (GetArenaForAllocation() == nullptr && grid_ != nullptr) {
    delete grid_;
  }
  grid_ = nullptr;
}
inline const ::DTCC::Grid& Raster::_internal_grid() const {
  const ::DTCC::Grid* p = grid_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Grid&>(
      ::DTCC::_Grid_default_instance_);
}
inline const ::DTCC::Grid& Raster::grid() const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.grid)
  return _internal_grid();
}
inline void Raster::unsafe_arena_set_allocated_grid(
    ::DTCC::Grid* grid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grid_);
  }
  grid_ = grid;
  if (grid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Raster.grid)
}
inline ::DTCC::Grid* Raster::release_grid() {
  
  ::DTCC::Grid* temp = grid_;
  grid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DTCC::Grid* Raster::unsafe_arena_release_grid() {
  // @@protoc_insertion_point(field_release:DTCC.Raster.grid)
  
  ::DTCC::Grid* temp = grid_;
  grid_ = nullptr;
  return temp;
}
inline ::DTCC::Grid* Raster::_internal_mutable_grid() {
  
  if (grid_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Grid>(GetArenaForAllocation());
    grid_ = p;
  }
  return grid_;
}
inline ::DTCC::Grid* Raster::mutable_grid() {
  ::DTCC::Grid* _msg = _internal_mutable_grid();
  // @@protoc_insertion_point(field_mutable:DTCC.Raster.grid)
  return _msg;
}
inline void Raster::set_allocated_grid(::DTCC::Grid* grid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete grid_;
  }
  if (grid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DTCC::Grid>::GetOwningArena(grid);
    if (message_arena != submessage_arena) {
      grid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grid, submessage_arena);
    }
    
  } else {
    
  }
  grid_ = grid;
  // @@protoc_insertion_point(field_set_allocated:DTCC.Raster.grid)
}

// int32 dim = 5;
inline void Raster::clear_dim() {
  dim_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Raster::_internal_dim() const {
  return dim_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Raster::dim() const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.dim)
  return _internal_dim();
}
inline void Raster::_internal_set_dim(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dim_ = value;
}
inline void Raster::set_dim(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dim(value);
  // @@protoc_insertion_point(field_set:DTCC.Raster.dim)
}

// repeated float values = 6;
inline int Raster::_internal_values_size() const {
  return values_.size();
}
inline int Raster::values_size() const {
  return _internal_values_size();
}
inline void Raster::clear_values() {
  values_.Clear();
}
inline float Raster::_internal_values(int index) const {
  return values_.Get(index);
}
inline float Raster::values(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.values)
  return _internal_values(index);
}
inline void Raster::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Raster.values)
}
inline void Raster::_internal_add_values(float value) {
  values_.Add(value);
}
inline void Raster::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:DTCC.Raster.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Raster::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Raster::values() const {
  // @@protoc_insertion_point(field_list:DTCC.Raster.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Raster::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Raster::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Raster.values)
  return _internal_mutable_values();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DTCC

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dtcc_2eproto
