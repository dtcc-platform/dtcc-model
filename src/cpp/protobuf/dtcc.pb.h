// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dtcc.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_dtcc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_dtcc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dtcc_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dtcc_2eproto {
  static const ::uint32_t offsets[];
};
namespace DTCC {
class Bounds;
struct BoundsDefaultTypeInternal;
extern BoundsDefaultTypeInternal _Bounds_default_instance_;
class Building;
struct BuildingDefaultTypeInternal;
extern BuildingDefaultTypeInternal _Building_default_instance_;
class BuildingPart;
struct BuildingPartDefaultTypeInternal;
extern BuildingPartDefaultTypeInternal _BuildingPart_default_instance_;
class City;
struct CityDefaultTypeInternal;
extern CityDefaultTypeInternal _City_default_instance_;
class Grid;
struct GridDefaultTypeInternal;
extern GridDefaultTypeInternal _Grid_default_instance_;
class LineString;
struct LineStringDefaultTypeInternal;
extern LineStringDefaultTypeInternal _LineString_default_instance_;
class Mesh;
struct MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class MultiSurface;
struct MultiSurfaceDefaultTypeInternal;
extern MultiSurfaceDefaultTypeInternal _MultiSurface_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class PointCloud;
struct PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class Quantity;
struct QuantityDefaultTypeInternal;
extern QuantityDefaultTypeInternal _Quantity_default_instance_;
class Raster;
struct RasterDefaultTypeInternal;
extern RasterDefaultTypeInternal _Raster_default_instance_;
class Surface;
struct SurfaceDefaultTypeInternal;
extern SurfaceDefaultTypeInternal _Surface_default_instance_;
class Terrain;
struct TerrainDefaultTypeInternal;
extern TerrainDefaultTypeInternal _Terrain_default_instance_;
class Transform;
struct TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class VolumeGrid;
struct VolumeGridDefaultTypeInternal;
extern VolumeGridDefaultTypeInternal _VolumeGrid_default_instance_;
class VolumeMesh;
struct VolumeMeshDefaultTypeInternal;
extern VolumeMeshDefaultTypeInternal _VolumeMesh_default_instance_;
}  // namespace DTCC
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace DTCC {

// ===================================================================


// -------------------------------------------------------------------

class VolumeMesh final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.VolumeMesh) */ {
 public:
  inline VolumeMesh() : VolumeMesh(nullptr) {}
  ~VolumeMesh() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeMesh(::google::protobuf::internal::ConstantInitialized);

  inline VolumeMesh(const VolumeMesh& from)
      : VolumeMesh(nullptr, from) {}
  VolumeMesh(VolumeMesh&& from) noexcept
    : VolumeMesh() {
    *this = ::std::move(from);
  }

  inline VolumeMesh& operator=(const VolumeMesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeMesh& operator=(VolumeMesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VolumeMesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeMesh* internal_default_instance() {
    return reinterpret_cast<const VolumeMesh*>(
               &_VolumeMesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VolumeMesh& a, VolumeMesh& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeMesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeMesh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeMesh* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeMesh>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const VolumeMesh& from);
  void MergeFrom(const VolumeMesh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeMesh* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.VolumeMesh";
  }
  protected:
  explicit VolumeMesh(::google::protobuf::Arena* arena);
  VolumeMesh(::google::protobuf::Arena* arena, const VolumeMesh& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kCellsFieldNumber = 2,
  };
  // repeated float vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;

  public:
  void clear_vertices() ;
  float vertices(int index) const;
  void set_vertices(int index, float value);
  void add_vertices(float value);
  const ::google::protobuf::RepeatedField<float>& vertices() const;
  ::google::protobuf::RepeatedField<float>* mutable_vertices();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vertices() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vertices();

  public:
  // repeated float cells = 2;
  int cells_size() const;
  private:
  int _internal_cells_size() const;

  public:
  void clear_cells() ;
  float cells(int index) const;
  void set_cells(int index, float value);
  void add_cells(float value);
  const ::google::protobuf::RepeatedField<float>& cells() const;
  ::google::protobuf::RepeatedField<float>* mutable_cells();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_cells() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_cells();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.VolumeMesh)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> vertices_;
    ::google::protobuf::RepeatedField<float> cells_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Transform final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  ~Transform() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Transform(::google::protobuf::internal::ConstantInitialized);

  inline Transform(const Transform& from)
      : Transform(nullptr, from) {}
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Transform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transform* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Transform* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Transform";
  }
  protected:
  explicit Transform(::google::protobuf::Arena* arena);
  Transform(::google::protobuf::Arena* arena, const Transform& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffineFieldNumber = 2,
    kSrsFieldNumber = 1,
  };
  // repeated float affine = 2;
  int affine_size() const;
  private:
  int _internal_affine_size() const;

  public:
  void clear_affine() ;
  float affine(int index) const;
  void set_affine(int index, float value);
  void add_affine(float value);
  const ::google::protobuf::RepeatedField<float>& affine() const;
  ::google::protobuf::RepeatedField<float>* mutable_affine();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_affine() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_affine();

  public:
  // string srs = 1;
  void clear_srs() ;
  const std::string& srs() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_srs(Arg_&& arg, Args_... args);
  std::string* mutable_srs();
  PROTOBUF_NODISCARD std::string* release_srs();
  void set_allocated_srs(std::string* value);

  private:
  const std::string& _internal_srs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srs(
      const std::string& value);
  std::string* _internal_mutable_srs();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Transform)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      26, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> affine_;
    ::google::protobuf::internal::ArenaStringPtr srs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Raster final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Raster) */ {
 public:
  inline Raster() : Raster(nullptr) {}
  ~Raster() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Raster(::google::protobuf::internal::ConstantInitialized);

  inline Raster(const Raster& from)
      : Raster(nullptr, from) {}
  Raster(Raster&& from) noexcept
    : Raster() {
    *this = ::std::move(from);
  }

  inline Raster& operator=(const Raster& from) {
    CopyFrom(from);
    return *this;
  }
  inline Raster& operator=(Raster&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Raster& default_instance() {
    return *internal_default_instance();
  }
  static inline const Raster* internal_default_instance() {
    return reinterpret_cast<const Raster*>(
               &_Raster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Raster& a, Raster& b) {
    a.Swap(&b);
  }
  inline void Swap(Raster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Raster* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Raster* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Raster>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Raster& from);
  void MergeFrom(const Raster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Raster* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Raster";
  }
  protected:
  explicit Raster(::google::protobuf::Arena* arena);
  Raster(::google::protobuf::Arena* arena, const Raster& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kHeighFieldNumber = 2,
    kWidthFieldNumber = 3,
    kDimsFieldNumber = 4,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField<float>& data() const;
  ::google::protobuf::RepeatedField<float>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_data() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_data();

  public:
  // uint32 heigh = 2;
  void clear_heigh() ;
  ::uint32_t heigh() const;
  void set_heigh(::uint32_t value);

  private:
  ::uint32_t _internal_heigh() const;
  void _internal_set_heigh(::uint32_t value);

  public:
  // uint32 width = 3;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 dims = 4;
  void clear_dims() ;
  ::uint32_t dims() const;
  void set_dims(::uint32_t value);

  private:
  ::uint32_t _internal_dims() const;
  void _internal_set_dims(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Raster)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> data_;
    ::uint32_t heigh_;
    ::uint32_t width_;
    ::uint32_t dims_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Quantity final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Quantity) */ {
 public:
  inline Quantity() : Quantity(nullptr) {}
  ~Quantity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Quantity(::google::protobuf::internal::ConstantInitialized);

  inline Quantity(const Quantity& from)
      : Quantity(nullptr, from) {}
  Quantity(Quantity&& from) noexcept
    : Quantity() {
    *this = ::std::move(from);
  }

  inline Quantity& operator=(const Quantity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quantity& operator=(Quantity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Quantity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quantity* internal_default_instance() {
    return reinterpret_cast<const Quantity*>(
               &_Quantity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Quantity& a, Quantity& b) {
    a.Swap(&b);
  }
  inline void Swap(Quantity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quantity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quantity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quantity>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Quantity& from);
  void MergeFrom(const Quantity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Quantity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Quantity";
  }
  protected:
  explicit Quantity(::google::protobuf::Arena* arena);
  Quantity(::google::protobuf::Arena* arena, const Quantity& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 6,
    kNameFieldNumber = 1,
    kUnitFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kGeometryFieldNumber = 4,
    kDimFieldNumber = 5,
  };
  // repeated float values = 6;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField<float>& values() const;
  ::google::protobuf::RepeatedField<float>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_values() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_values();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string unit = 2;
  void clear_unit() ;
  const std::string& unit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unit(Arg_&& arg, Args_... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* value);

  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(
      const std::string& value);
  std::string* _internal_mutable_unit();

  public:
  // string description = 3;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string geometry = 4;
  void clear_geometry() ;
  const std::string& geometry() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_geometry(Arg_&& arg, Args_... args);
  std::string* mutable_geometry();
  PROTOBUF_NODISCARD std::string* release_geometry();
  void set_allocated_geometry(std::string* value);

  private:
  const std::string& _internal_geometry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_geometry(
      const std::string& value);
  std::string* _internal_mutable_geometry();

  public:
  // int32 dim = 5;
  void clear_dim() ;
  ::int32_t dim() const;
  void set_dim(::int32_t value);

  private:
  ::int32_t _internal_dim() const;
  void _internal_set_dim(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Quantity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> values_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr unit_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr geometry_;
    ::int32_t dim_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class LineString final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.LineString) */ {
 public:
  inline LineString() : LineString(nullptr) {}
  ~LineString() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LineString(::google::protobuf::internal::ConstantInitialized);

  inline LineString(const LineString& from)
      : LineString(nullptr, from) {}
  LineString(LineString&& from) noexcept
    : LineString() {
    *this = ::std::move(from);
  }

  inline LineString& operator=(const LineString& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineString& operator=(LineString&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LineString& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineString* internal_default_instance() {
    return reinterpret_cast<const LineString*>(
               &_LineString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LineString& a, LineString& b) {
    a.Swap(&b);
  }
  inline void Swap(LineString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineString* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineString* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineString>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const LineString& from);
  void MergeFrom(const LineString& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LineString* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.LineString";
  }
  protected:
  explicit LineString(::google::protobuf::Arena* arena);
  LineString(::google::protobuf::Arena* arena, const LineString& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
  };
  // repeated float vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;

  public:
  void clear_vertices() ;
  float vertices(int index) const;
  void set_vertices(int index, float value);
  void add_vertices(float value);
  const ::google::protobuf::RepeatedField<float>& vertices() const;
  ::google::protobuf::RepeatedField<float>* mutable_vertices();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vertices() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vertices();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.LineString)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> vertices_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Bounds final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Bounds) */ {
 public:
  inline Bounds() : Bounds(nullptr) {}
  ~Bounds() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bounds(::google::protobuf::internal::ConstantInitialized);

  inline Bounds(const Bounds& from)
      : Bounds(nullptr, from) {}
  Bounds(Bounds&& from) noexcept
    : Bounds() {
    *this = ::std::move(from);
  }

  inline Bounds& operator=(const Bounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bounds& operator=(Bounds&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Bounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bounds* internal_default_instance() {
    return reinterpret_cast<const Bounds*>(
               &_Bounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Bounds& a, Bounds& b) {
    a.Swap(&b);
  }
  inline void Swap(Bounds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bounds* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bounds* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bounds>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Bounds& from);
  void MergeFrom(const Bounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Bounds* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Bounds";
  }
  protected:
  explicit Bounds(::google::protobuf::Arena* arena);
  Bounds(::google::protobuf::Arena* arena, const Bounds& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXminFieldNumber = 1,
    kYminFieldNumber = 2,
    kZminFieldNumber = 3,
    kXmaxFieldNumber = 4,
    kYmaxFieldNumber = 5,
    kZmaxFieldNumber = 6,
  };
  // float xmin = 1;
  void clear_xmin() ;
  float xmin() const;
  void set_xmin(float value);

  private:
  float _internal_xmin() const;
  void _internal_set_xmin(float value);

  public:
  // float ymin = 2;
  void clear_ymin() ;
  float ymin() const;
  void set_ymin(float value);

  private:
  float _internal_ymin() const;
  void _internal_set_ymin(float value);

  public:
  // float zmin = 3;
  void clear_zmin() ;
  float zmin() const;
  void set_zmin(float value);

  private:
  float _internal_zmin() const;
  void _internal_set_zmin(float value);

  public:
  // float xmax = 4;
  void clear_xmax() ;
  float xmax() const;
  void set_xmax(float value);

  private:
  float _internal_xmax() const;
  void _internal_set_xmax(float value);

  public:
  // float ymax = 5;
  void clear_ymax() ;
  float ymax() const;
  void set_ymax(float value);

  private:
  float _internal_ymax() const;
  void _internal_set_ymax(float value);

  public:
  // float zmax = 6;
  void clear_zmax() ;
  float zmax() const;
  void set_zmax(float value);

  private:
  float _internal_zmax() const;
  void _internal_set_zmax(float value);

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Bounds)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float xmin_;
    float ymin_;
    float zmin_;
    float xmax_;
    float ymax_;
    float zmax_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class VolumeGrid final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.VolumeGrid) */ {
 public:
  inline VolumeGrid() : VolumeGrid(nullptr) {}
  ~VolumeGrid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeGrid(::google::protobuf::internal::ConstantInitialized);

  inline VolumeGrid(const VolumeGrid& from)
      : VolumeGrid(nullptr, from) {}
  VolumeGrid(VolumeGrid&& from) noexcept
    : VolumeGrid() {
    *this = ::std::move(from);
  }

  inline VolumeGrid& operator=(const VolumeGrid& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeGrid& operator=(VolumeGrid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VolumeGrid& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeGrid* internal_default_instance() {
    return reinterpret_cast<const VolumeGrid*>(
               &_VolumeGrid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VolumeGrid& a, VolumeGrid& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeGrid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeGrid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeGrid* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeGrid>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const VolumeGrid& from);
  void MergeFrom(const VolumeGrid& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeGrid* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.VolumeGrid";
  }
  protected:
  explicit VolumeGrid(::google::protobuf::Arena* arena);
  VolumeGrid(::google::protobuf::Arena* arena, const VolumeGrid& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundsFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kDepthFieldNumber = 4,
  };
  // .DTCC.Bounds bounds = 1;
  bool has_bounds() const;
  void clear_bounds() ;
  const ::DTCC::Bounds& bounds() const;
  PROTOBUF_NODISCARD ::DTCC::Bounds* release_bounds();
  ::DTCC::Bounds* mutable_bounds();
  void set_allocated_bounds(::DTCC::Bounds* value);
  void unsafe_arena_set_allocated_bounds(::DTCC::Bounds* value);
  ::DTCC::Bounds* unsafe_arena_release_bounds();

  private:
  const ::DTCC::Bounds& _internal_bounds() const;
  ::DTCC::Bounds* _internal_mutable_bounds();

  public:
  // int32 width = 2;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 3;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // int32 depth = 4;
  void clear_depth() ;
  ::int32_t depth() const;
  void set_depth(::int32_t value);

  private:
  ::int32_t _internal_depth() const;
  void _internal_set_depth(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DTCC.VolumeGrid)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::DTCC::Bounds* bounds_;
    ::int32_t width_;
    ::int32_t height_;
    ::int32_t depth_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Surface final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Surface) */ {
 public:
  inline Surface() : Surface(nullptr) {}
  ~Surface() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Surface(::google::protobuf::internal::ConstantInitialized);

  inline Surface(const Surface& from)
      : Surface(nullptr, from) {}
  Surface(Surface&& from) noexcept
    : Surface() {
    *this = ::std::move(from);
  }

  inline Surface& operator=(const Surface& from) {
    CopyFrom(from);
    return *this;
  }
  inline Surface& operator=(Surface&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Surface& default_instance() {
    return *internal_default_instance();
  }
  static inline const Surface* internal_default_instance() {
    return reinterpret_cast<const Surface*>(
               &_Surface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Surface& a, Surface& b) {
    a.Swap(&b);
  }
  inline void Swap(Surface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Surface* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Surface* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Surface>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Surface& from);
  void MergeFrom(const Surface& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Surface* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Surface";
  }
  protected:
  explicit Surface(::google::protobuf::Arena* arena);
  Surface(::google::protobuf::Arena* arena, const Surface& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kHolesFieldNumber = 2,
    kTransformFieldNumber = 3,
  };
  // repeated float vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;

  public:
  void clear_vertices() ;
  float vertices(int index) const;
  void set_vertices(int index, float value);
  void add_vertices(float value);
  const ::google::protobuf::RepeatedField<float>& vertices() const;
  ::google::protobuf::RepeatedField<float>* mutable_vertices();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vertices() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vertices();

  public:
  // repeated .DTCC.LineString holes = 2;
  int holes_size() const;
  private:
  int _internal_holes_size() const;

  public:
  void clear_holes() ;
  ::DTCC::LineString* mutable_holes(int index);
  ::google::protobuf::RepeatedPtrField< ::DTCC::LineString >*
      mutable_holes();
  private:
  const ::google::protobuf::RepeatedPtrField<::DTCC::LineString>& _internal_holes() const;
  ::google::protobuf::RepeatedPtrField<::DTCC::LineString>* _internal_mutable_holes();
  public:
  const ::DTCC::LineString& holes(int index) const;
  ::DTCC::LineString* add_holes();
  const ::google::protobuf::RepeatedPtrField< ::DTCC::LineString >&
      holes() const;
  // .DTCC.Transform transform = 3;
  bool has_transform() const;
  void clear_transform() ;
  const ::DTCC::Transform& transform() const;
  PROTOBUF_NODISCARD ::DTCC::Transform* release_transform();
  ::DTCC::Transform* mutable_transform();
  void set_allocated_transform(::DTCC::Transform* value);
  void unsafe_arena_set_allocated_transform(::DTCC::Transform* value);
  ::DTCC::Transform* unsafe_arena_release_transform();

  private:
  const ::DTCC::Transform& _internal_transform() const;
  ::DTCC::Transform* _internal_mutable_transform();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Surface)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> vertices_;
    ::google::protobuf::RepeatedPtrField< ::DTCC::LineString > holes_;
    ::DTCC::Transform* transform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class PointCloud final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.PointCloud) */ {
 public:
  inline PointCloud() : PointCloud(nullptr) {}
  ~PointCloud() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointCloud(::google::protobuf::internal::ConstantInitialized);

  inline PointCloud(const PointCloud& from)
      : PointCloud(nullptr, from) {}
  PointCloud(PointCloud&& from) noexcept
    : PointCloud() {
    *this = ::std::move(from);
  }

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointCloud& operator=(PointCloud&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PointCloud& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PointCloud& a, PointCloud& b) {
    a.Swap(&b);
  }
  inline void Swap(PointCloud* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointCloud* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointCloud* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointCloud>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PointCloud* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.PointCloud";
  }
  protected:
  explicit PointCloud(::google::protobuf::Arena* arena);
  PointCloud(::google::protobuf::Arena* arena, const PointCloud& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kClassificationFieldNumber = 2,
    kIntensityFieldNumber = 3,
    kReturnNumberFieldNumber = 4,
    kNumReturnsFieldNumber = 5,
    kBoundsFieldNumber = 6,
    kTransformFieldNumber = 7,
  };
  // repeated float points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  float points(int index) const;
  void set_points(int index, float value);
  void add_points(float value);
  const ::google::protobuf::RepeatedField<float>& points() const;
  ::google::protobuf::RepeatedField<float>* mutable_points();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_points() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_points();

  public:
  // repeated uint32 classification = 2;
  int classification_size() const;
  private:
  int _internal_classification_size() const;

  public:
  void clear_classification() ;
  ::uint32_t classification(int index) const;
  void set_classification(int index, ::uint32_t value);
  void add_classification(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& classification() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_classification();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_classification() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_classification();

  public:
  // repeated uint32 intensity = 3;
  int intensity_size() const;
  private:
  int _internal_intensity_size() const;

  public:
  void clear_intensity() ;
  ::uint32_t intensity(int index) const;
  void set_intensity(int index, ::uint32_t value);
  void add_intensity(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& intensity() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_intensity();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_intensity() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_intensity();

  public:
  // repeated uint32 return_number = 4;
  int return_number_size() const;
  private:
  int _internal_return_number_size() const;

  public:
  void clear_return_number() ;
  ::uint32_t return_number(int index) const;
  void set_return_number(int index, ::uint32_t value);
  void add_return_number(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& return_number() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_return_number();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_return_number() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_return_number();

  public:
  // repeated uint32 num_returns = 5;
  int num_returns_size() const;
  private:
  int _internal_num_returns_size() const;

  public:
  void clear_num_returns() ;
  ::uint32_t num_returns(int index) const;
  void set_num_returns(int index, ::uint32_t value);
  void add_num_returns(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& num_returns() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_num_returns();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_num_returns() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_num_returns();

  public:
  // .DTCC.Bounds bounds = 6;
  bool has_bounds() const;
  void clear_bounds() ;
  const ::DTCC::Bounds& bounds() const;
  PROTOBUF_NODISCARD ::DTCC::Bounds* release_bounds();
  ::DTCC::Bounds* mutable_bounds();
  void set_allocated_bounds(::DTCC::Bounds* value);
  void unsafe_arena_set_allocated_bounds(::DTCC::Bounds* value);
  ::DTCC::Bounds* unsafe_arena_release_bounds();

  private:
  const ::DTCC::Bounds& _internal_bounds() const;
  ::DTCC::Bounds* _internal_mutable_bounds();

  public:
  // .DTCC.Transform transform = 7;
  bool has_transform() const;
  void clear_transform() ;
  const ::DTCC::Transform& transform() const;
  PROTOBUF_NODISCARD ::DTCC::Transform* release_transform();
  ::DTCC::Transform* mutable_transform();
  void set_allocated_transform(::DTCC::Transform* value);
  void unsafe_arena_set_allocated_transform(::DTCC::Transform* value);
  ::DTCC::Transform* unsafe_arena_release_transform();

  private:
  const ::DTCC::Transform& _internal_transform() const;
  ::DTCC::Transform* _internal_mutable_transform();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.PointCloud)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> points_;
    ::google::protobuf::RepeatedField<::uint32_t> classification_;
    mutable ::google::protobuf::internal::CachedSize _classification_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> intensity_;
    mutable ::google::protobuf::internal::CachedSize _intensity_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> return_number_;
    mutable ::google::protobuf::internal::CachedSize _return_number_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> num_returns_;
    mutable ::google::protobuf::internal::CachedSize _num_returns_cached_byte_size_;
    ::DTCC::Bounds* bounds_;
    ::DTCC::Transform* transform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Mesh final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Mesh) */ {
 public:
  inline Mesh() : Mesh(nullptr) {}
  ~Mesh() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Mesh(::google::protobuf::internal::ConstantInitialized);

  inline Mesh(const Mesh& from)
      : Mesh(nullptr, from) {}
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Mesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Mesh* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Mesh";
  }
  protected:
  explicit Mesh(::google::protobuf::Arena* arena);
  Mesh(::google::protobuf::Arena* arena, const Mesh& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticeFieldNumber = 1,
    kNormalsFieldNumber = 2,
    kFacesFieldNumber = 3,
    kTransformFieldNumber = 4,
  };
  // repeated float vertice = 1;
  int vertice_size() const;
  private:
  int _internal_vertice_size() const;

  public:
  void clear_vertice() ;
  float vertice(int index) const;
  void set_vertice(int index, float value);
  void add_vertice(float value);
  const ::google::protobuf::RepeatedField<float>& vertice() const;
  ::google::protobuf::RepeatedField<float>* mutable_vertice();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vertice() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vertice();

  public:
  // repeated float normals = 2;
  int normals_size() const;
  private:
  int _internal_normals_size() const;

  public:
  void clear_normals() ;
  float normals(int index) const;
  void set_normals(int index, float value);
  void add_normals(float value);
  const ::google::protobuf::RepeatedField<float>& normals() const;
  ::google::protobuf::RepeatedField<float>* mutable_normals();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_normals() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_normals();

  public:
  // repeated uint32 faces = 3;
  int faces_size() const;
  private:
  int _internal_faces_size() const;

  public:
  void clear_faces() ;
  ::uint32_t faces(int index) const;
  void set_faces(int index, ::uint32_t value);
  void add_faces(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& faces() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_faces();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_faces() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_faces();

  public:
  // .DTCC.Transform transform = 4;
  bool has_transform() const;
  void clear_transform() ;
  const ::DTCC::Transform& transform() const;
  PROTOBUF_NODISCARD ::DTCC::Transform* release_transform();
  ::DTCC::Transform* mutable_transform();
  void set_allocated_transform(::DTCC::Transform* value);
  void unsafe_arena_set_allocated_transform(::DTCC::Transform* value);
  ::DTCC::Transform* unsafe_arena_release_transform();

  private:
  const ::DTCC::Transform& _internal_transform() const;
  ::DTCC::Transform* _internal_mutable_transform();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Mesh)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> vertice_;
    ::google::protobuf::RepeatedField<float> normals_;
    ::google::protobuf::RepeatedField<::uint32_t> faces_;
    mutable ::google::protobuf::internal::CachedSize _faces_cached_byte_size_;
    ::DTCC::Transform* transform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Grid final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Grid) */ {
 public:
  inline Grid() : Grid(nullptr) {}
  ~Grid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Grid(::google::protobuf::internal::ConstantInitialized);

  inline Grid(const Grid& from)
      : Grid(nullptr, from) {}
  Grid(Grid&& from) noexcept
    : Grid() {
    *this = ::std::move(from);
  }

  inline Grid& operator=(const Grid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid& operator=(Grid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Grid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid* internal_default_instance() {
    return reinterpret_cast<const Grid*>(
               &_Grid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Grid& a, Grid& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Grid& from);
  void MergeFrom(const Grid& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Grid* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Grid";
  }
  protected:
  explicit Grid(::google::protobuf::Arena* arena);
  Grid(::google::protobuf::Arena* arena, const Grid& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundsFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // .DTCC.Bounds bounds = 1;
  bool has_bounds() const;
  void clear_bounds() ;
  const ::DTCC::Bounds& bounds() const;
  PROTOBUF_NODISCARD ::DTCC::Bounds* release_bounds();
  ::DTCC::Bounds* mutable_bounds();
  void set_allocated_bounds(::DTCC::Bounds* value);
  void unsafe_arena_set_allocated_bounds(::DTCC::Bounds* value);
  ::DTCC::Bounds* unsafe_arena_release_bounds();

  private:
  const ::DTCC::Bounds& _internal_bounds() const;
  ::DTCC::Bounds* _internal_mutable_bounds();

  public:
  // int32 width = 2;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 3;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Grid)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::DTCC::Bounds* bounds_;
    ::int32_t width_;
    ::int32_t height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class MultiSurface final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.MultiSurface) */ {
 public:
  inline MultiSurface() : MultiSurface(nullptr) {}
  ~MultiSurface() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MultiSurface(::google::protobuf::internal::ConstantInitialized);

  inline MultiSurface(const MultiSurface& from)
      : MultiSurface(nullptr, from) {}
  MultiSurface(MultiSurface&& from) noexcept
    : MultiSurface() {
    *this = ::std::move(from);
  }

  inline MultiSurface& operator=(const MultiSurface& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiSurface& operator=(MultiSurface&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MultiSurface& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiSurface* internal_default_instance() {
    return reinterpret_cast<const MultiSurface*>(
               &_MultiSurface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MultiSurface& a, MultiSurface& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiSurface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiSurface* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiSurface* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiSurface>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const MultiSurface& from);
  void MergeFrom(const MultiSurface& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MultiSurface* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.MultiSurface";
  }
  protected:
  explicit MultiSurface(::google::protobuf::Arena* arena);
  MultiSurface(::google::protobuf::Arena* arena, const MultiSurface& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSurfacesFieldNumber = 1,
    kTransformFieldNumber = 2,
  };
  // repeated .DTCC.Surface surfaces = 1;
  int surfaces_size() const;
  private:
  int _internal_surfaces_size() const;

  public:
  void clear_surfaces() ;
  ::DTCC::Surface* mutable_surfaces(int index);
  ::google::protobuf::RepeatedPtrField< ::DTCC::Surface >*
      mutable_surfaces();
  private:
  const ::google::protobuf::RepeatedPtrField<::DTCC::Surface>& _internal_surfaces() const;
  ::google::protobuf::RepeatedPtrField<::DTCC::Surface>* _internal_mutable_surfaces();
  public:
  const ::DTCC::Surface& surfaces(int index) const;
  ::DTCC::Surface* add_surfaces();
  const ::google::protobuf::RepeatedPtrField< ::DTCC::Surface >&
      surfaces() const;
  // .DTCC.Transform transform = 2;
  bool has_transform() const;
  void clear_transform() ;
  const ::DTCC::Transform& transform() const;
  PROTOBUF_NODISCARD ::DTCC::Transform* release_transform();
  ::DTCC::Transform* mutable_transform();
  void set_allocated_transform(::DTCC::Transform* value);
  void unsafe_arena_set_allocated_transform(::DTCC::Transform* value);
  ::DTCC::Transform* unsafe_arena_release_transform();

  private:
  const ::DTCC::Transform& _internal_transform() const;
  ::DTCC::Transform* _internal_mutable_transform();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.MultiSurface)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DTCC::Surface > surfaces_;
    ::DTCC::Transform* transform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Object final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Object(::google::protobuf::internal::ConstantInitialized);

  inline Object(const Object& from)
      : Object(nullptr, from) {}
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Object* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Object";
  }
  protected:
  explicit Object(::google::protobuf::Arena* arena);
  Object(::google::protobuf::Arena* arena, const Object& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAttributesFieldNumber = 2,
    kLod0FieldNumber = 3,
    kLod1FieldNumber = 4,
    kLod2FieldNumber = 5,
    kLod3FieldNumber = 6,
    kMeshFieldNumber = 7,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string attributes = 2;
  void clear_attributes() ;
  const std::string& attributes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attributes(Arg_&& arg, Args_... args);
  std::string* mutable_attributes();
  PROTOBUF_NODISCARD std::string* release_attributes();
  void set_allocated_attributes(std::string* value);

  private:
  const std::string& _internal_attributes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributes(
      const std::string& value);
  std::string* _internal_mutable_attributes();

  public:
  // .DTCC.MultiSurface lod0 = 3;
  bool has_lod0() const;
  void clear_lod0() ;
  const ::DTCC::MultiSurface& lod0() const;
  PROTOBUF_NODISCARD ::DTCC::MultiSurface* release_lod0();
  ::DTCC::MultiSurface* mutable_lod0();
  void set_allocated_lod0(::DTCC::MultiSurface* value);
  void unsafe_arena_set_allocated_lod0(::DTCC::MultiSurface* value);
  ::DTCC::MultiSurface* unsafe_arena_release_lod0();

  private:
  const ::DTCC::MultiSurface& _internal_lod0() const;
  ::DTCC::MultiSurface* _internal_mutable_lod0();

  public:
  // .DTCC.MultiSurface lod1 = 4;
  bool has_lod1() const;
  void clear_lod1() ;
  const ::DTCC::MultiSurface& lod1() const;
  PROTOBUF_NODISCARD ::DTCC::MultiSurface* release_lod1();
  ::DTCC::MultiSurface* mutable_lod1();
  void set_allocated_lod1(::DTCC::MultiSurface* value);
  void unsafe_arena_set_allocated_lod1(::DTCC::MultiSurface* value);
  ::DTCC::MultiSurface* unsafe_arena_release_lod1();

  private:
  const ::DTCC::MultiSurface& _internal_lod1() const;
  ::DTCC::MultiSurface* _internal_mutable_lod1();

  public:
  // .DTCC.MultiSurface lod2 = 5;
  bool has_lod2() const;
  void clear_lod2() ;
  const ::DTCC::MultiSurface& lod2() const;
  PROTOBUF_NODISCARD ::DTCC::MultiSurface* release_lod2();
  ::DTCC::MultiSurface* mutable_lod2();
  void set_allocated_lod2(::DTCC::MultiSurface* value);
  void unsafe_arena_set_allocated_lod2(::DTCC::MultiSurface* value);
  ::DTCC::MultiSurface* unsafe_arena_release_lod2();

  private:
  const ::DTCC::MultiSurface& _internal_lod2() const;
  ::DTCC::MultiSurface* _internal_mutable_lod2();

  public:
  // .DTCC.MultiSurface lod3 = 6;
  bool has_lod3() const;
  void clear_lod3() ;
  const ::DTCC::MultiSurface& lod3() const;
  PROTOBUF_NODISCARD ::DTCC::MultiSurface* release_lod3();
  ::DTCC::MultiSurface* mutable_lod3();
  void set_allocated_lod3(::DTCC::MultiSurface* value);
  void unsafe_arena_set_allocated_lod3(::DTCC::MultiSurface* value);
  ::DTCC::MultiSurface* unsafe_arena_release_lod3();

  private:
  const ::DTCC::MultiSurface& _internal_lod3() const;
  ::DTCC::MultiSurface* _internal_mutable_lod3();

  public:
  // .DTCC.Mesh mesh = 7;
  bool has_mesh() const;
  void clear_mesh() ;
  const ::DTCC::Mesh& mesh() const;
  PROTOBUF_NODISCARD ::DTCC::Mesh* release_mesh();
  ::DTCC::Mesh* mutable_mesh();
  void set_allocated_mesh(::DTCC::Mesh* value);
  void unsafe_arena_set_allocated_mesh(::DTCC::Mesh* value);
  ::DTCC::Mesh* unsafe_arena_release_mesh();

  private:
  const ::DTCC::Mesh& _internal_mesh() const;
  ::DTCC::Mesh* _internal_mutable_mesh();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Object)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr attributes_;
    ::DTCC::MultiSurface* lod0_;
    ::DTCC::MultiSurface* lod1_;
    ::DTCC::MultiSurface* lod2_;
    ::DTCC::MultiSurface* lod3_;
    ::DTCC::Mesh* mesh_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Terrain final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Terrain) */ {
 public:
  inline Terrain() : Terrain(nullptr) {}
  ~Terrain() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Terrain(::google::protobuf::internal::ConstantInitialized);

  inline Terrain(const Terrain& from)
      : Terrain(nullptr, from) {}
  Terrain(Terrain&& from) noexcept
    : Terrain() {
    *this = ::std::move(from);
  }

  inline Terrain& operator=(const Terrain& from) {
    CopyFrom(from);
    return *this;
  }
  inline Terrain& operator=(Terrain&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Terrain& default_instance() {
    return *internal_default_instance();
  }
  static inline const Terrain* internal_default_instance() {
    return reinterpret_cast<const Terrain*>(
               &_Terrain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Terrain& a, Terrain& b) {
    a.Swap(&b);
  }
  inline void Swap(Terrain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Terrain* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Terrain* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Terrain>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Terrain& from);
  void MergeFrom(const Terrain& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Terrain* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Terrain";
  }
  protected:
  explicit Terrain(::google::protobuf::Arena* arena);
  Terrain(::google::protobuf::Arena* arena, const Terrain& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .DTCC.Object object = 1;
  bool has_object() const;
  void clear_object() ;
  const ::DTCC::Object& object() const;
  PROTOBUF_NODISCARD ::DTCC::Object* release_object();
  ::DTCC::Object* mutable_object();
  void set_allocated_object(::DTCC::Object* value);
  void unsafe_arena_set_allocated_object(::DTCC::Object* value);
  ::DTCC::Object* unsafe_arena_release_object();

  private:
  const ::DTCC::Object& _internal_object() const;
  ::DTCC::Object* _internal_mutable_object();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Terrain)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::DTCC::Object* object_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class BuildingPart final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.BuildingPart) */ {
 public:
  inline BuildingPart() : BuildingPart(nullptr) {}
  ~BuildingPart() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BuildingPart(::google::protobuf::internal::ConstantInitialized);

  inline BuildingPart(const BuildingPart& from)
      : BuildingPart(nullptr, from) {}
  BuildingPart(BuildingPart&& from) noexcept
    : BuildingPart() {
    *this = ::std::move(from);
  }

  inline BuildingPart& operator=(const BuildingPart& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildingPart& operator=(BuildingPart&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BuildingPart& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildingPart* internal_default_instance() {
    return reinterpret_cast<const BuildingPart*>(
               &_BuildingPart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BuildingPart& a, BuildingPart& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildingPart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildingPart* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuildingPart* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuildingPart>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BuildingPart& from);
  void MergeFrom(const BuildingPart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuildingPart* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.BuildingPart";
  }
  protected:
  explicit BuildingPart(::google::protobuf::Arena* arena);
  BuildingPart(::google::protobuf::Arena* arena, const BuildingPart& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .DTCC.Object object = 1;
  bool has_object() const;
  void clear_object() ;
  const ::DTCC::Object& object() const;
  PROTOBUF_NODISCARD ::DTCC::Object* release_object();
  ::DTCC::Object* mutable_object();
  void set_allocated_object(::DTCC::Object* value);
  void unsafe_arena_set_allocated_object(::DTCC::Object* value);
  ::DTCC::Object* unsafe_arena_release_object();

  private:
  const ::DTCC::Object& _internal_object() const;
  ::DTCC::Object* _internal_mutable_object();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.BuildingPart)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::DTCC::Object* object_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class Building final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.Building) */ {
 public:
  inline Building() : Building(nullptr) {}
  ~Building() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Building(::google::protobuf::internal::ConstantInitialized);

  inline Building(const Building& from)
      : Building(nullptr, from) {}
  Building(Building&& from) noexcept
    : Building() {
    *this = ::std::move(from);
  }

  inline Building& operator=(const Building& from) {
    CopyFrom(from);
    return *this;
  }
  inline Building& operator=(Building&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Building& default_instance() {
    return *internal_default_instance();
  }
  static inline const Building* internal_default_instance() {
    return reinterpret_cast<const Building*>(
               &_Building_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Building& a, Building& b) {
    a.Swap(&b);
  }
  inline void Swap(Building* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Building* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Building* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Building>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Building& from);
  void MergeFrom(const Building& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Building* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.Building";
  }
  protected:
  explicit Building(::google::protobuf::Arena* arena);
  Building(::google::protobuf::Arena* arena, const Building& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kObjectFieldNumber = 1,
  };
  // repeated .DTCC.BuildingPart children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;

  public:
  void clear_children() ;
  ::DTCC::BuildingPart* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::DTCC::BuildingPart >*
      mutable_children();
  private:
  const ::google::protobuf::RepeatedPtrField<::DTCC::BuildingPart>& _internal_children() const;
  ::google::protobuf::RepeatedPtrField<::DTCC::BuildingPart>* _internal_mutable_children();
  public:
  const ::DTCC::BuildingPart& children(int index) const;
  ::DTCC::BuildingPart* add_children();
  const ::google::protobuf::RepeatedPtrField< ::DTCC::BuildingPart >&
      children() const;
  // .DTCC.Object object = 1;
  bool has_object() const;
  void clear_object() ;
  const ::DTCC::Object& object() const;
  PROTOBUF_NODISCARD ::DTCC::Object* release_object();
  ::DTCC::Object* mutable_object();
  void set_allocated_object(::DTCC::Object* value);
  void unsafe_arena_set_allocated_object(::DTCC::Object* value);
  ::DTCC::Object* unsafe_arena_release_object();

  private:
  const ::DTCC::Object& _internal_object() const;
  ::DTCC::Object* _internal_mutable_object();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.Building)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DTCC::BuildingPart > children_;
    ::DTCC::Object* object_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};// -------------------------------------------------------------------

class City final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DTCC.City) */ {
 public:
  inline City() : City(nullptr) {}
  ~City() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR City(::google::protobuf::internal::ConstantInitialized);

  inline City(const City& from)
      : City(nullptr, from) {}
  City(City&& from) noexcept
    : City() {
    *this = ::std::move(from);
  }

  inline City& operator=(const City& from) {
    CopyFrom(from);
    return *this;
  }
  inline City& operator=(City&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const City& default_instance() {
    return *internal_default_instance();
  }
  static inline const City* internal_default_instance() {
    return reinterpret_cast<const City*>(
               &_City_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(City& a, City& b) {
    a.Swap(&b);
  }
  inline void Swap(City* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(City* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  City* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<City>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const City& from);
  void MergeFrom(const City& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(City* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DTCC.City";
  }
  protected:
  explicit City(::google::protobuf::Arena* arena);
  City(::google::protobuf::Arena* arena, const City& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildingsFieldNumber = 1,
    kTerrainFieldNumber = 2,
  };
  // repeated .DTCC.Building buildings = 1;
  int buildings_size() const;
  private:
  int _internal_buildings_size() const;

  public:
  void clear_buildings() ;
  ::DTCC::Building* mutable_buildings(int index);
  ::google::protobuf::RepeatedPtrField< ::DTCC::Building >*
      mutable_buildings();
  private:
  const ::google::protobuf::RepeatedPtrField<::DTCC::Building>& _internal_buildings() const;
  ::google::protobuf::RepeatedPtrField<::DTCC::Building>* _internal_mutable_buildings();
  public:
  const ::DTCC::Building& buildings(int index) const;
  ::DTCC::Building* add_buildings();
  const ::google::protobuf::RepeatedPtrField< ::DTCC::Building >&
      buildings() const;
  // .DTCC.Terrain terrain = 2;
  bool has_terrain() const;
  void clear_terrain() ;
  const ::DTCC::Terrain& terrain() const;
  PROTOBUF_NODISCARD ::DTCC::Terrain* release_terrain();
  ::DTCC::Terrain* mutable_terrain();
  void set_allocated_terrain(::DTCC::Terrain* value);
  void unsafe_arena_set_allocated_terrain(::DTCC::Terrain* value);
  ::DTCC::Terrain* unsafe_arena_release_terrain();

  private:
  const ::DTCC::Terrain& _internal_terrain() const;
  ::DTCC::Terrain* _internal_mutable_terrain();

  public:
  // @@protoc_insertion_point(class_scope:DTCC.City)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DTCC::Building > buildings_;
    ::DTCC::Terrain* terrain_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtcc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Object

// string id = 1;
inline void Object::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Object::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Object.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Object::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DTCC.Object.id)
}
inline std::string* Object::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.id)
  return _s;
}
inline const std::string& Object::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Object::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Object::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Object::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Object.id)
  return _impl_.id_.Release();
}
inline void Object::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.id)
}

// string attributes = 2;
inline void Object::clear_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attributes_.ClearToEmpty();
}
inline const std::string& Object::attributes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Object.attributes)
  return _internal_attributes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Object::set_attributes(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attributes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DTCC.Object.attributes)
}
inline std::string* Object::mutable_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.attributes)
  return _s;
}
inline const std::string& Object::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_.Get();
}
inline void Object::_internal_set_attributes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attributes_.Set(value, GetArena());
}
inline std::string* Object::_internal_mutable_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.attributes_.Mutable( GetArena());
}
inline std::string* Object::release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Object.attributes)
  return _impl_.attributes_.Release();
}
inline void Object::set_allocated_attributes(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attributes_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attributes_.IsDefault()) {
          _impl_.attributes_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.attributes)
}

// .DTCC.MultiSurface lod0 = 3;
inline bool Object::has_lod0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lod0_ != nullptr);
  return value;
}
inline void Object::clear_lod0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lod0_ != nullptr) _impl_.lod0_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::MultiSurface& Object::_internal_lod0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::MultiSurface* p = _impl_.lod0_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::MultiSurface&>(::DTCC::_MultiSurface_default_instance_);
}
inline const ::DTCC::MultiSurface& Object::lod0() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Object.lod0)
  return _internal_lod0();
}
inline void Object::unsafe_arena_set_allocated_lod0(::DTCC::MultiSurface* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lod0_);
  }
  _impl_.lod0_ = reinterpret_cast<::DTCC::MultiSurface*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.lod0)
}
inline ::DTCC::MultiSurface* Object::release_lod0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::MultiSurface* released = _impl_.lod0_;
  _impl_.lod0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::MultiSurface* Object::unsafe_arena_release_lod0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Object.lod0)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::MultiSurface* temp = _impl_.lod0_;
  _impl_.lod0_ = nullptr;
  return temp;
}
inline ::DTCC::MultiSurface* Object::_internal_mutable_lod0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lod0_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::MultiSurface>(GetArena());
    _impl_.lod0_ = reinterpret_cast<::DTCC::MultiSurface*>(p);
  }
  return _impl_.lod0_;
}
inline ::DTCC::MultiSurface* Object::mutable_lod0() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::MultiSurface* _msg = _internal_mutable_lod0();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.lod0)
  return _msg;
}
inline void Object::set_allocated_lod0(::DTCC::MultiSurface* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::MultiSurface*>(_impl_.lod0_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::MultiSurface*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lod0_ = reinterpret_cast<::DTCC::MultiSurface*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.lod0)
}

// .DTCC.MultiSurface lod1 = 4;
inline bool Object::has_lod1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lod1_ != nullptr);
  return value;
}
inline void Object::clear_lod1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lod1_ != nullptr) _impl_.lod1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DTCC::MultiSurface& Object::_internal_lod1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::MultiSurface* p = _impl_.lod1_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::MultiSurface&>(::DTCC::_MultiSurface_default_instance_);
}
inline const ::DTCC::MultiSurface& Object::lod1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Object.lod1)
  return _internal_lod1();
}
inline void Object::unsafe_arena_set_allocated_lod1(::DTCC::MultiSurface* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lod1_);
  }
  _impl_.lod1_ = reinterpret_cast<::DTCC::MultiSurface*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.lod1)
}
inline ::DTCC::MultiSurface* Object::release_lod1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DTCC::MultiSurface* released = _impl_.lod1_;
  _impl_.lod1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::MultiSurface* Object::unsafe_arena_release_lod1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Object.lod1)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DTCC::MultiSurface* temp = _impl_.lod1_;
  _impl_.lod1_ = nullptr;
  return temp;
}
inline ::DTCC::MultiSurface* Object::_internal_mutable_lod1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lod1_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::MultiSurface>(GetArena());
    _impl_.lod1_ = reinterpret_cast<::DTCC::MultiSurface*>(p);
  }
  return _impl_.lod1_;
}
inline ::DTCC::MultiSurface* Object::mutable_lod1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::MultiSurface* _msg = _internal_mutable_lod1();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.lod1)
  return _msg;
}
inline void Object::set_allocated_lod1(::DTCC::MultiSurface* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::MultiSurface*>(_impl_.lod1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::MultiSurface*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lod1_ = reinterpret_cast<::DTCC::MultiSurface*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.lod1)
}

// .DTCC.MultiSurface lod2 = 5;
inline bool Object::has_lod2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lod2_ != nullptr);
  return value;
}
inline void Object::clear_lod2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lod2_ != nullptr) _impl_.lod2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::DTCC::MultiSurface& Object::_internal_lod2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::MultiSurface* p = _impl_.lod2_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::MultiSurface&>(::DTCC::_MultiSurface_default_instance_);
}
inline const ::DTCC::MultiSurface& Object::lod2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Object.lod2)
  return _internal_lod2();
}
inline void Object::unsafe_arena_set_allocated_lod2(::DTCC::MultiSurface* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lod2_);
  }
  _impl_.lod2_ = reinterpret_cast<::DTCC::MultiSurface*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.lod2)
}
inline ::DTCC::MultiSurface* Object::release_lod2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DTCC::MultiSurface* released = _impl_.lod2_;
  _impl_.lod2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::MultiSurface* Object::unsafe_arena_release_lod2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Object.lod2)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DTCC::MultiSurface* temp = _impl_.lod2_;
  _impl_.lod2_ = nullptr;
  return temp;
}
inline ::DTCC::MultiSurface* Object::_internal_mutable_lod2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.lod2_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::MultiSurface>(GetArena());
    _impl_.lod2_ = reinterpret_cast<::DTCC::MultiSurface*>(p);
  }
  return _impl_.lod2_;
}
inline ::DTCC::MultiSurface* Object::mutable_lod2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::MultiSurface* _msg = _internal_mutable_lod2();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.lod2)
  return _msg;
}
inline void Object::set_allocated_lod2(::DTCC::MultiSurface* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::MultiSurface*>(_impl_.lod2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::MultiSurface*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.lod2_ = reinterpret_cast<::DTCC::MultiSurface*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.lod2)
}

// .DTCC.MultiSurface lod3 = 6;
inline bool Object::has_lod3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lod3_ != nullptr);
  return value;
}
inline void Object::clear_lod3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lod3_ != nullptr) _impl_.lod3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::DTCC::MultiSurface& Object::_internal_lod3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::MultiSurface* p = _impl_.lod3_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::MultiSurface&>(::DTCC::_MultiSurface_default_instance_);
}
inline const ::DTCC::MultiSurface& Object::lod3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Object.lod3)
  return _internal_lod3();
}
inline void Object::unsafe_arena_set_allocated_lod3(::DTCC::MultiSurface* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lod3_);
  }
  _impl_.lod3_ = reinterpret_cast<::DTCC::MultiSurface*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.lod3)
}
inline ::DTCC::MultiSurface* Object::release_lod3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::DTCC::MultiSurface* released = _impl_.lod3_;
  _impl_.lod3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::MultiSurface* Object::unsafe_arena_release_lod3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Object.lod3)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::DTCC::MultiSurface* temp = _impl_.lod3_;
  _impl_.lod3_ = nullptr;
  return temp;
}
inline ::DTCC::MultiSurface* Object::_internal_mutable_lod3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.lod3_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::MultiSurface>(GetArena());
    _impl_.lod3_ = reinterpret_cast<::DTCC::MultiSurface*>(p);
  }
  return _impl_.lod3_;
}
inline ::DTCC::MultiSurface* Object::mutable_lod3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::MultiSurface* _msg = _internal_mutable_lod3();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.lod3)
  return _msg;
}
inline void Object::set_allocated_lod3(::DTCC::MultiSurface* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::MultiSurface*>(_impl_.lod3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::MultiSurface*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.lod3_ = reinterpret_cast<::DTCC::MultiSurface*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.lod3)
}

// .DTCC.Mesh mesh = 7;
inline bool Object::has_mesh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mesh_ != nullptr);
  return value;
}
inline void Object::clear_mesh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.mesh_ != nullptr) _impl_.mesh_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::DTCC::Mesh& Object::_internal_mesh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Mesh* p = _impl_.mesh_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Mesh&>(::DTCC::_Mesh_default_instance_);
}
inline const ::DTCC::Mesh& Object::mesh() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Object.mesh)
  return _internal_mesh();
}
inline void Object::unsafe_arena_set_allocated_mesh(::DTCC::Mesh* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mesh_);
  }
  _impl_.mesh_ = reinterpret_cast<::DTCC::Mesh*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Object.mesh)
}
inline ::DTCC::Mesh* Object::release_mesh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DTCC::Mesh* released = _impl_.mesh_;
  _impl_.mesh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Mesh* Object::unsafe_arena_release_mesh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Object.mesh)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DTCC::Mesh* temp = _impl_.mesh_;
  _impl_.mesh_ = nullptr;
  return temp;
}
inline ::DTCC::Mesh* Object::_internal_mutable_mesh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.mesh_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Mesh>(GetArena());
    _impl_.mesh_ = reinterpret_cast<::DTCC::Mesh*>(p);
  }
  return _impl_.mesh_;
}
inline ::DTCC::Mesh* Object::mutable_mesh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Mesh* _msg = _internal_mutable_mesh();
  // @@protoc_insertion_point(field_mutable:DTCC.Object.mesh)
  return _msg;
}
inline void Object::set_allocated_mesh(::DTCC::Mesh* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Mesh*>(_impl_.mesh_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Mesh*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.mesh_ = reinterpret_cast<::DTCC::Mesh*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Object.mesh)
}

// -------------------------------------------------------------------

// Building

// .DTCC.Object object = 1;
inline bool Building::has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline void Building::clear_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.object_ != nullptr) _impl_.object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Object& Building::_internal_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Object* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Object&>(::DTCC::_Object_default_instance_);
}
inline const ::DTCC::Object& Building::object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Building.object)
  return _internal_object();
}
inline void Building::unsafe_arena_set_allocated_object(::DTCC::Object* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = reinterpret_cast<::DTCC::Object*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Building.object)
}
inline ::DTCC::Object* Building::release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Object* released = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Object* Building::unsafe_arena_release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Building.object)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::DTCC::Object* Building::_internal_mutable_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Object>(GetArena());
    _impl_.object_ = reinterpret_cast<::DTCC::Object*>(p);
  }
  return _impl_.object_;
}
inline ::DTCC::Object* Building::mutable_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:DTCC.Building.object)
  return _msg;
}
inline void Building::set_allocated_object(::DTCC::Object* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Object*>(_impl_.object_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Object*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_ = reinterpret_cast<::DTCC::Object*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Building.object)
}

// repeated .DTCC.BuildingPart children = 2;
inline int Building::_internal_children_size() const {
  return _internal_children().size();
}
inline int Building::children_size() const {
  return _internal_children_size();
}
inline void Building::clear_children() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.children_.Clear();
}
inline ::DTCC::BuildingPart* Building::mutable_children(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DTCC.Building.children)
  return _internal_mutable_children()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DTCC::BuildingPart>* Building::mutable_children()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Building.children)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_children();
}
inline const ::DTCC::BuildingPart& Building::children(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Building.children)
  return _internal_children().Get(index);
}
inline ::DTCC::BuildingPart* Building::add_children() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DTCC::BuildingPart* _add = _internal_mutable_children()->Add();
  // @@protoc_insertion_point(field_add:DTCC.Building.children)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DTCC::BuildingPart>& Building::children() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Building.children)
  return _internal_children();
}
inline const ::google::protobuf::RepeatedPtrField<::DTCC::BuildingPart>&
Building::_internal_children() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.children_;
}
inline ::google::protobuf::RepeatedPtrField<::DTCC::BuildingPart>*
Building::_internal_mutable_children() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.children_;
}

// -------------------------------------------------------------------

// BuildingPart

// .DTCC.Object object = 1;
inline bool BuildingPart::has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline void BuildingPart::clear_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.object_ != nullptr) _impl_.object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Object& BuildingPart::_internal_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Object* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Object&>(::DTCC::_Object_default_instance_);
}
inline const ::DTCC::Object& BuildingPart::object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.BuildingPart.object)
  return _internal_object();
}
inline void BuildingPart::unsafe_arena_set_allocated_object(::DTCC::Object* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = reinterpret_cast<::DTCC::Object*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.BuildingPart.object)
}
inline ::DTCC::Object* BuildingPart::release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Object* released = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Object* BuildingPart::unsafe_arena_release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.BuildingPart.object)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::DTCC::Object* BuildingPart::_internal_mutable_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Object>(GetArena());
    _impl_.object_ = reinterpret_cast<::DTCC::Object*>(p);
  }
  return _impl_.object_;
}
inline ::DTCC::Object* BuildingPart::mutable_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:DTCC.BuildingPart.object)
  return _msg;
}
inline void BuildingPart::set_allocated_object(::DTCC::Object* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Object*>(_impl_.object_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Object*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_ = reinterpret_cast<::DTCC::Object*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.BuildingPart.object)
}

// -------------------------------------------------------------------

// Terrain

// .DTCC.Object object = 1;
inline bool Terrain::has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline void Terrain::clear_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.object_ != nullptr) _impl_.object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Object& Terrain::_internal_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Object* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Object&>(::DTCC::_Object_default_instance_);
}
inline const ::DTCC::Object& Terrain::object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Terrain.object)
  return _internal_object();
}
inline void Terrain::unsafe_arena_set_allocated_object(::DTCC::Object* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = reinterpret_cast<::DTCC::Object*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Terrain.object)
}
inline ::DTCC::Object* Terrain::release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Object* released = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Object* Terrain::unsafe_arena_release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Terrain.object)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::DTCC::Object* Terrain::_internal_mutable_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Object>(GetArena());
    _impl_.object_ = reinterpret_cast<::DTCC::Object*>(p);
  }
  return _impl_.object_;
}
inline ::DTCC::Object* Terrain::mutable_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:DTCC.Terrain.object)
  return _msg;
}
inline void Terrain::set_allocated_object(::DTCC::Object* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Object*>(_impl_.object_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Object*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_ = reinterpret_cast<::DTCC::Object*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Terrain.object)
}

// -------------------------------------------------------------------

// City

// repeated .DTCC.Building buildings = 1;
inline int City::_internal_buildings_size() const {
  return _internal_buildings().size();
}
inline int City::buildings_size() const {
  return _internal_buildings_size();
}
inline void City::clear_buildings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buildings_.Clear();
}
inline ::DTCC::Building* City::mutable_buildings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DTCC.City.buildings)
  return _internal_mutable_buildings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DTCC::Building>* City::mutable_buildings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.City.buildings)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_buildings();
}
inline const ::DTCC::Building& City::buildings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.City.buildings)
  return _internal_buildings().Get(index);
}
inline ::DTCC::Building* City::add_buildings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DTCC::Building* _add = _internal_mutable_buildings()->Add();
  // @@protoc_insertion_point(field_add:DTCC.City.buildings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DTCC::Building>& City::buildings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.City.buildings)
  return _internal_buildings();
}
inline const ::google::protobuf::RepeatedPtrField<::DTCC::Building>&
City::_internal_buildings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buildings_;
}
inline ::google::protobuf::RepeatedPtrField<::DTCC::Building>*
City::_internal_mutable_buildings() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.buildings_;
}

// .DTCC.Terrain terrain = 2;
inline bool City::has_terrain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.terrain_ != nullptr);
  return value;
}
inline void City::clear_terrain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.terrain_ != nullptr) _impl_.terrain_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Terrain& City::_internal_terrain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Terrain* p = _impl_.terrain_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Terrain&>(::DTCC::_Terrain_default_instance_);
}
inline const ::DTCC::Terrain& City::terrain() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.City.terrain)
  return _internal_terrain();
}
inline void City::unsafe_arena_set_allocated_terrain(::DTCC::Terrain* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.terrain_);
  }
  _impl_.terrain_ = reinterpret_cast<::DTCC::Terrain*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.City.terrain)
}
inline ::DTCC::Terrain* City::release_terrain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Terrain* released = _impl_.terrain_;
  _impl_.terrain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Terrain* City::unsafe_arena_release_terrain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.City.terrain)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Terrain* temp = _impl_.terrain_;
  _impl_.terrain_ = nullptr;
  return temp;
}
inline ::DTCC::Terrain* City::_internal_mutable_terrain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.terrain_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Terrain>(GetArena());
    _impl_.terrain_ = reinterpret_cast<::DTCC::Terrain*>(p);
  }
  return _impl_.terrain_;
}
inline ::DTCC::Terrain* City::mutable_terrain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Terrain* _msg = _internal_mutable_terrain();
  // @@protoc_insertion_point(field_mutable:DTCC.City.terrain)
  return _msg;
}
inline void City::set_allocated_terrain(::DTCC::Terrain* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Terrain*>(_impl_.terrain_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Terrain*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.terrain_ = reinterpret_cast<::DTCC::Terrain*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.City.terrain)
}

// -------------------------------------------------------------------

// Quantity

// string name = 1;
inline void Quantity::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Quantity::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Quantity::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DTCC.Quantity.name)
}
inline std::string* Quantity::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DTCC.Quantity.name)
  return _s;
}
inline const std::string& Quantity::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Quantity::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Quantity::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Quantity::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Quantity.name)
  return _impl_.name_.Release();
}
inline void Quantity::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DTCC.Quantity.name)
}

// string unit = 2;
inline void Quantity::clear_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& Quantity::unit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.unit)
  return _internal_unit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Quantity::set_unit(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DTCC.Quantity.unit)
}
inline std::string* Quantity::mutable_unit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:DTCC.Quantity.unit)
  return _s;
}
inline const std::string& Quantity::_internal_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unit_.Get();
}
inline void Quantity::_internal_set_unit(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unit_.Set(value, GetArena());
}
inline std::string* Quantity::_internal_mutable_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.unit_.Mutable( GetArena());
}
inline std::string* Quantity::release_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Quantity.unit)
  return _impl_.unit_.Release();
}
inline void Quantity::set_allocated_unit(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unit_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unit_.IsDefault()) {
          _impl_.unit_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DTCC.Quantity.unit)
}

// string description = 3;
inline void Quantity::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Quantity::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Quantity::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DTCC.Quantity.description)
}
inline std::string* Quantity::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:DTCC.Quantity.description)
  return _s;
}
inline const std::string& Quantity::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void Quantity::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Quantity::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Quantity::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Quantity.description)
  return _impl_.description_.Release();
}
inline void Quantity::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DTCC.Quantity.description)
}

// string geometry = 4;
inline void Quantity::clear_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.geometry_.ClearToEmpty();
}
inline const std::string& Quantity::geometry() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.geometry)
  return _internal_geometry();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Quantity::set_geometry(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.geometry_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DTCC.Quantity.geometry)
}
inline std::string* Quantity::mutable_geometry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:DTCC.Quantity.geometry)
  return _s;
}
inline const std::string& Quantity::_internal_geometry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geometry_.Get();
}
inline void Quantity::_internal_set_geometry(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.geometry_.Set(value, GetArena());
}
inline std::string* Quantity::_internal_mutable_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.geometry_.Mutable( GetArena());
}
inline std::string* Quantity::release_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Quantity.geometry)
  return _impl_.geometry_.Release();
}
inline void Quantity::set_allocated_geometry(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.geometry_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.geometry_.IsDefault()) {
          _impl_.geometry_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DTCC.Quantity.geometry)
}

// int32 dim = 5;
inline void Quantity::clear_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dim_ = 0;
}
inline ::int32_t Quantity::dim() const {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.dim)
  return _internal_dim();
}
inline void Quantity::set_dim(::int32_t value) {
  _internal_set_dim(value);
  // @@protoc_insertion_point(field_set:DTCC.Quantity.dim)
}
inline ::int32_t Quantity::_internal_dim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dim_;
}
inline void Quantity::_internal_set_dim(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dim_ = value;
}

// repeated float values = 6;
inline int Quantity::_internal_values_size() const {
  return _internal_values().size();
}
inline int Quantity::values_size() const {
  return _internal_values_size();
}
inline void Quantity::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline float Quantity::values(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Quantity.values)
  return _internal_values().Get(index);
}
inline void Quantity::set_values(int index, float value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Quantity.values)
}
inline void Quantity::add_values(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.Quantity.values)
}
inline const ::google::protobuf::RepeatedField<float>& Quantity::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Quantity.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<float>* Quantity::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Quantity.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<float>& Quantity::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<float>* Quantity::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Bounds

// float xmin = 1;
inline void Bounds::clear_xmin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.xmin_ = 0;
}
inline float Bounds::xmin() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.xmin)
  return _internal_xmin();
}
inline void Bounds::set_xmin(float value) {
  _internal_set_xmin(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.xmin)
}
inline float Bounds::_internal_xmin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.xmin_;
}
inline void Bounds::_internal_set_xmin(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.xmin_ = value;
}

// float ymin = 2;
inline void Bounds::clear_ymin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ymin_ = 0;
}
inline float Bounds::ymin() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.ymin)
  return _internal_ymin();
}
inline void Bounds::set_ymin(float value) {
  _internal_set_ymin(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.ymin)
}
inline float Bounds::_internal_ymin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ymin_;
}
inline void Bounds::_internal_set_ymin(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ymin_ = value;
}

// float zmin = 3;
inline void Bounds::clear_zmin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zmin_ = 0;
}
inline float Bounds::zmin() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.zmin)
  return _internal_zmin();
}
inline void Bounds::set_zmin(float value) {
  _internal_set_zmin(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.zmin)
}
inline float Bounds::_internal_zmin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zmin_;
}
inline void Bounds::_internal_set_zmin(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zmin_ = value;
}

// float xmax = 4;
inline void Bounds::clear_xmax() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.xmax_ = 0;
}
inline float Bounds::xmax() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.xmax)
  return _internal_xmax();
}
inline void Bounds::set_xmax(float value) {
  _internal_set_xmax(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.xmax)
}
inline float Bounds::_internal_xmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.xmax_;
}
inline void Bounds::_internal_set_xmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.xmax_ = value;
}

// float ymax = 5;
inline void Bounds::clear_ymax() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ymax_ = 0;
}
inline float Bounds::ymax() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.ymax)
  return _internal_ymax();
}
inline void Bounds::set_ymax(float value) {
  _internal_set_ymax(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.ymax)
}
inline float Bounds::_internal_ymax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ymax_;
}
inline void Bounds::_internal_set_ymax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ymax_ = value;
}

// float zmax = 6;
inline void Bounds::clear_zmax() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zmax_ = 0;
}
inline float Bounds::zmax() const {
  // @@protoc_insertion_point(field_get:DTCC.Bounds.zmax)
  return _internal_zmax();
}
inline void Bounds::set_zmax(float value) {
  _internal_set_zmax(value);
  // @@protoc_insertion_point(field_set:DTCC.Bounds.zmax)
}
inline float Bounds::_internal_zmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zmax_;
}
inline void Bounds::_internal_set_zmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zmax_ = value;
}

// -------------------------------------------------------------------

// LineString

// repeated float vertices = 1;
inline int LineString::_internal_vertices_size() const {
  return _internal_vertices().size();
}
inline int LineString::vertices_size() const {
  return _internal_vertices_size();
}
inline void LineString::clear_vertices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vertices_.Clear();
}
inline float LineString::vertices(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.LineString.vertices)
  return _internal_vertices().Get(index);
}
inline void LineString::set_vertices(int index, float value) {
  _internal_mutable_vertices()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.LineString.vertices)
}
inline void LineString::add_vertices(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vertices()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.LineString.vertices)
}
inline const ::google::protobuf::RepeatedField<float>& LineString::vertices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.LineString.vertices)
  return _internal_vertices();
}
inline ::google::protobuf::RepeatedField<float>* LineString::mutable_vertices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.LineString.vertices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vertices();
}
inline const ::google::protobuf::RepeatedField<float>& LineString::_internal_vertices()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vertices_;
}
inline ::google::protobuf::RepeatedField<float>* LineString::_internal_mutable_vertices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vertices_;
}

// -------------------------------------------------------------------

// Surface

// repeated float vertices = 1;
inline int Surface::_internal_vertices_size() const {
  return _internal_vertices().size();
}
inline int Surface::vertices_size() const {
  return _internal_vertices_size();
}
inline void Surface::clear_vertices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vertices_.Clear();
}
inline float Surface::vertices(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Surface.vertices)
  return _internal_vertices().Get(index);
}
inline void Surface::set_vertices(int index, float value) {
  _internal_mutable_vertices()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Surface.vertices)
}
inline void Surface::add_vertices(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vertices()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.Surface.vertices)
}
inline const ::google::protobuf::RepeatedField<float>& Surface::vertices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Surface.vertices)
  return _internal_vertices();
}
inline ::google::protobuf::RepeatedField<float>* Surface::mutable_vertices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Surface.vertices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vertices();
}
inline const ::google::protobuf::RepeatedField<float>& Surface::_internal_vertices()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vertices_;
}
inline ::google::protobuf::RepeatedField<float>* Surface::_internal_mutable_vertices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vertices_;
}

// repeated .DTCC.LineString holes = 2;
inline int Surface::_internal_holes_size() const {
  return _internal_holes().size();
}
inline int Surface::holes_size() const {
  return _internal_holes_size();
}
inline void Surface::clear_holes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.holes_.Clear();
}
inline ::DTCC::LineString* Surface::mutable_holes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DTCC.Surface.holes)
  return _internal_mutable_holes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DTCC::LineString>* Surface::mutable_holes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Surface.holes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_holes();
}
inline const ::DTCC::LineString& Surface::holes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Surface.holes)
  return _internal_holes().Get(index);
}
inline ::DTCC::LineString* Surface::add_holes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DTCC::LineString* _add = _internal_mutable_holes()->Add();
  // @@protoc_insertion_point(field_add:DTCC.Surface.holes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DTCC::LineString>& Surface::holes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Surface.holes)
  return _internal_holes();
}
inline const ::google::protobuf::RepeatedPtrField<::DTCC::LineString>&
Surface::_internal_holes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.holes_;
}
inline ::google::protobuf::RepeatedPtrField<::DTCC::LineString>*
Surface::_internal_mutable_holes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.holes_;
}

// .DTCC.Transform transform = 3;
inline bool Surface::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void Surface::clear_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Transform& Surface::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Transform&>(::DTCC::_Transform_default_instance_);
}
inline const ::DTCC::Transform& Surface::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Surface.transform)
  return _internal_transform();
}
inline void Surface::unsafe_arena_set_allocated_transform(::DTCC::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Surface.transform)
}
inline ::DTCC::Transform* Surface::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Transform* Surface::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Surface.transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::DTCC::Transform* Surface::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::DTCC::Transform* Surface::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:DTCC.Surface.transform)
  return _msg;
}
inline void Surface::set_allocated_transform(::DTCC::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Transform*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Transform*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Surface.transform)
}

// -------------------------------------------------------------------

// MultiSurface

// repeated .DTCC.Surface surfaces = 1;
inline int MultiSurface::_internal_surfaces_size() const {
  return _internal_surfaces().size();
}
inline int MultiSurface::surfaces_size() const {
  return _internal_surfaces_size();
}
inline void MultiSurface::clear_surfaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.surfaces_.Clear();
}
inline ::DTCC::Surface* MultiSurface::mutable_surfaces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DTCC.MultiSurface.surfaces)
  return _internal_mutable_surfaces()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DTCC::Surface>* MultiSurface::mutable_surfaces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.MultiSurface.surfaces)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_surfaces();
}
inline const ::DTCC::Surface& MultiSurface::surfaces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.MultiSurface.surfaces)
  return _internal_surfaces().Get(index);
}
inline ::DTCC::Surface* MultiSurface::add_surfaces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DTCC::Surface* _add = _internal_mutable_surfaces()->Add();
  // @@protoc_insertion_point(field_add:DTCC.MultiSurface.surfaces)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DTCC::Surface>& MultiSurface::surfaces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.MultiSurface.surfaces)
  return _internal_surfaces();
}
inline const ::google::protobuf::RepeatedPtrField<::DTCC::Surface>&
MultiSurface::_internal_surfaces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.surfaces_;
}
inline ::google::protobuf::RepeatedPtrField<::DTCC::Surface>*
MultiSurface::_internal_mutable_surfaces() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.surfaces_;
}

// .DTCC.Transform transform = 2;
inline bool MultiSurface::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void MultiSurface::clear_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Transform& MultiSurface::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Transform&>(::DTCC::_Transform_default_instance_);
}
inline const ::DTCC::Transform& MultiSurface::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.MultiSurface.transform)
  return _internal_transform();
}
inline void MultiSurface::unsafe_arena_set_allocated_transform(::DTCC::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.MultiSurface.transform)
}
inline ::DTCC::Transform* MultiSurface::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Transform* MultiSurface::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.MultiSurface.transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::DTCC::Transform* MultiSurface::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::DTCC::Transform* MultiSurface::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:DTCC.MultiSurface.transform)
  return _msg;
}
inline void MultiSurface::set_allocated_transform(::DTCC::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Transform*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Transform*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.MultiSurface.transform)
}

// -------------------------------------------------------------------

// Mesh

// repeated float vertice = 1;
inline int Mesh::_internal_vertice_size() const {
  return _internal_vertice().size();
}
inline int Mesh::vertice_size() const {
  return _internal_vertice_size();
}
inline void Mesh::clear_vertice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vertice_.Clear();
}
inline float Mesh::vertice(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Mesh.vertice)
  return _internal_vertice().Get(index);
}
inline void Mesh::set_vertice(int index, float value) {
  _internal_mutable_vertice()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Mesh.vertice)
}
inline void Mesh::add_vertice(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vertice()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.Mesh.vertice)
}
inline const ::google::protobuf::RepeatedField<float>& Mesh::vertice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Mesh.vertice)
  return _internal_vertice();
}
inline ::google::protobuf::RepeatedField<float>* Mesh::mutable_vertice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Mesh.vertice)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vertice();
}
inline const ::google::protobuf::RepeatedField<float>& Mesh::_internal_vertice()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vertice_;
}
inline ::google::protobuf::RepeatedField<float>* Mesh::_internal_mutable_vertice() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vertice_;
}

// repeated float normals = 2;
inline int Mesh::_internal_normals_size() const {
  return _internal_normals().size();
}
inline int Mesh::normals_size() const {
  return _internal_normals_size();
}
inline void Mesh::clear_normals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.normals_.Clear();
}
inline float Mesh::normals(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Mesh.normals)
  return _internal_normals().Get(index);
}
inline void Mesh::set_normals(int index, float value) {
  _internal_mutable_normals()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Mesh.normals)
}
inline void Mesh::add_normals(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_normals()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.Mesh.normals)
}
inline const ::google::protobuf::RepeatedField<float>& Mesh::normals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Mesh.normals)
  return _internal_normals();
}
inline ::google::protobuf::RepeatedField<float>* Mesh::mutable_normals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Mesh.normals)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_normals();
}
inline const ::google::protobuf::RepeatedField<float>& Mesh::_internal_normals()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.normals_;
}
inline ::google::protobuf::RepeatedField<float>* Mesh::_internal_mutable_normals() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.normals_;
}

// repeated uint32 faces = 3;
inline int Mesh::_internal_faces_size() const {
  return _internal_faces().size();
}
inline int Mesh::faces_size() const {
  return _internal_faces_size();
}
inline void Mesh::clear_faces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.faces_.Clear();
}
inline ::uint32_t Mesh::faces(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Mesh.faces)
  return _internal_faces().Get(index);
}
inline void Mesh::set_faces(int index, ::uint32_t value) {
  _internal_mutable_faces()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Mesh.faces)
}
inline void Mesh::add_faces(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_faces()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.Mesh.faces)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Mesh::faces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Mesh.faces)
  return _internal_faces();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Mesh::mutable_faces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Mesh.faces)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_faces();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Mesh::_internal_faces()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.faces_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Mesh::_internal_mutable_faces() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.faces_;
}

// .DTCC.Transform transform = 4;
inline bool Mesh::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void Mesh::clear_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Transform& Mesh::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Transform&>(::DTCC::_Transform_default_instance_);
}
inline const ::DTCC::Transform& Mesh::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Mesh.transform)
  return _internal_transform();
}
inline void Mesh::unsafe_arena_set_allocated_transform(::DTCC::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Mesh.transform)
}
inline ::DTCC::Transform* Mesh::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Transform* Mesh::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Mesh.transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::DTCC::Transform* Mesh::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::DTCC::Transform* Mesh::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:DTCC.Mesh.transform)
  return _msg;
}
inline void Mesh::set_allocated_transform(::DTCC::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Transform*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Transform*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Mesh.transform)
}

// -------------------------------------------------------------------

// VolumeMesh

// repeated float vertices = 1;
inline int VolumeMesh::_internal_vertices_size() const {
  return _internal_vertices().size();
}
inline int VolumeMesh::vertices_size() const {
  return _internal_vertices_size();
}
inline void VolumeMesh::clear_vertices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vertices_.Clear();
}
inline float VolumeMesh::vertices(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeMesh.vertices)
  return _internal_vertices().Get(index);
}
inline void VolumeMesh::set_vertices(int index, float value) {
  _internal_mutable_vertices()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeMesh.vertices)
}
inline void VolumeMesh::add_vertices(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vertices()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.VolumeMesh.vertices)
}
inline const ::google::protobuf::RepeatedField<float>& VolumeMesh::vertices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.VolumeMesh.vertices)
  return _internal_vertices();
}
inline ::google::protobuf::RepeatedField<float>* VolumeMesh::mutable_vertices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.VolumeMesh.vertices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vertices();
}
inline const ::google::protobuf::RepeatedField<float>& VolumeMesh::_internal_vertices()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vertices_;
}
inline ::google::protobuf::RepeatedField<float>* VolumeMesh::_internal_mutable_vertices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vertices_;
}

// repeated float cells = 2;
inline int VolumeMesh::_internal_cells_size() const {
  return _internal_cells().size();
}
inline int VolumeMesh::cells_size() const {
  return _internal_cells_size();
}
inline void VolumeMesh::clear_cells() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cells_.Clear();
}
inline float VolumeMesh::cells(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeMesh.cells)
  return _internal_cells().Get(index);
}
inline void VolumeMesh::set_cells(int index, float value) {
  _internal_mutable_cells()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeMesh.cells)
}
inline void VolumeMesh::add_cells(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cells()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.VolumeMesh.cells)
}
inline const ::google::protobuf::RepeatedField<float>& VolumeMesh::cells() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.VolumeMesh.cells)
  return _internal_cells();
}
inline ::google::protobuf::RepeatedField<float>* VolumeMesh::mutable_cells()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.VolumeMesh.cells)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cells();
}
inline const ::google::protobuf::RepeatedField<float>& VolumeMesh::_internal_cells()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cells_;
}
inline ::google::protobuf::RepeatedField<float>* VolumeMesh::_internal_mutable_cells() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cells_;
}

// -------------------------------------------------------------------

// PointCloud

// repeated float points = 1;
inline int PointCloud::_internal_points_size() const {
  return _internal_points().size();
}
inline int PointCloud::points_size() const {
  return _internal_points_size();
}
inline void PointCloud::clear_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.points_.Clear();
}
inline float PointCloud::points(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.points)
  return _internal_points().Get(index);
}
inline void PointCloud::set_points(int index, float value) {
  _internal_mutable_points()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.points)
}
inline void PointCloud::add_points(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_points()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.points)
}
inline const ::google::protobuf::RepeatedField<float>& PointCloud::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.points)
  return _internal_points();
}
inline ::google::protobuf::RepeatedField<float>* PointCloud::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_points();
}
inline const ::google::protobuf::RepeatedField<float>& PointCloud::_internal_points()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedField<float>* PointCloud::_internal_mutable_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.points_;
}

// repeated uint32 classification = 2;
inline int PointCloud::_internal_classification_size() const {
  return _internal_classification().size();
}
inline int PointCloud::classification_size() const {
  return _internal_classification_size();
}
inline void PointCloud::clear_classification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.classification_.Clear();
}
inline ::uint32_t PointCloud::classification(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.classification)
  return _internal_classification().Get(index);
}
inline void PointCloud::set_classification(int index, ::uint32_t value) {
  _internal_mutable_classification()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.classification)
}
inline void PointCloud::add_classification(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_classification()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.classification)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PointCloud::classification() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.classification)
  return _internal_classification();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PointCloud::mutable_classification()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.classification)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_classification();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PointCloud::_internal_classification()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.classification_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PointCloud::_internal_mutable_classification() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.classification_;
}

// repeated uint32 intensity = 3;
inline int PointCloud::_internal_intensity_size() const {
  return _internal_intensity().size();
}
inline int PointCloud::intensity_size() const {
  return _internal_intensity_size();
}
inline void PointCloud::clear_intensity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.intensity_.Clear();
}
inline ::uint32_t PointCloud::intensity(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.intensity)
  return _internal_intensity().Get(index);
}
inline void PointCloud::set_intensity(int index, ::uint32_t value) {
  _internal_mutable_intensity()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.intensity)
}
inline void PointCloud::add_intensity(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_intensity()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.intensity)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PointCloud::intensity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.intensity)
  return _internal_intensity();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PointCloud::mutable_intensity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.intensity)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_intensity();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PointCloud::_internal_intensity()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.intensity_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PointCloud::_internal_mutable_intensity() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.intensity_;
}

// repeated uint32 return_number = 4;
inline int PointCloud::_internal_return_number_size() const {
  return _internal_return_number().size();
}
inline int PointCloud::return_number_size() const {
  return _internal_return_number_size();
}
inline void PointCloud::clear_return_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.return_number_.Clear();
}
inline ::uint32_t PointCloud::return_number(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.return_number)
  return _internal_return_number().Get(index);
}
inline void PointCloud::set_return_number(int index, ::uint32_t value) {
  _internal_mutable_return_number()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.return_number)
}
inline void PointCloud::add_return_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_return_number()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.return_number)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PointCloud::return_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.return_number)
  return _internal_return_number();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PointCloud::mutable_return_number()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.return_number)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_return_number();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PointCloud::_internal_return_number()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.return_number_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PointCloud::_internal_mutable_return_number() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.return_number_;
}

// repeated uint32 num_returns = 5;
inline int PointCloud::_internal_num_returns_size() const {
  return _internal_num_returns().size();
}
inline int PointCloud::num_returns_size() const {
  return _internal_num_returns_size();
}
inline void PointCloud::clear_num_returns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_returns_.Clear();
}
inline ::uint32_t PointCloud::num_returns(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.num_returns)
  return _internal_num_returns().Get(index);
}
inline void PointCloud::set_num_returns(int index, ::uint32_t value) {
  _internal_mutable_num_returns()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.PointCloud.num_returns)
}
inline void PointCloud::add_num_returns(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_num_returns()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.PointCloud.num_returns)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PointCloud::num_returns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.PointCloud.num_returns)
  return _internal_num_returns();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PointCloud::mutable_num_returns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.PointCloud.num_returns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_num_returns();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PointCloud::_internal_num_returns()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_returns_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PointCloud::_internal_mutable_num_returns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.num_returns_;
}

// .DTCC.Bounds bounds = 6;
inline bool PointCloud::has_bounds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bounds_ != nullptr);
  return value;
}
inline void PointCloud::clear_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bounds_ != nullptr) _impl_.bounds_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Bounds& PointCloud::_internal_bounds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Bounds* p = _impl_.bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Bounds&>(::DTCC::_Bounds_default_instance_);
}
inline const ::DTCC::Bounds& PointCloud::bounds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.bounds)
  return _internal_bounds();
}
inline void PointCloud::unsafe_arena_set_allocated_bounds(::DTCC::Bounds* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bounds_);
  }
  _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.PointCloud.bounds)
}
inline ::DTCC::Bounds* PointCloud::release_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Bounds* released = _impl_.bounds_;
  _impl_.bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Bounds* PointCloud::unsafe_arena_release_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.PointCloud.bounds)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Bounds* temp = _impl_.bounds_;
  _impl_.bounds_ = nullptr;
  return temp;
}
inline ::DTCC::Bounds* PointCloud::_internal_mutable_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Bounds>(GetArena());
    _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(p);
  }
  return _impl_.bounds_;
}
inline ::DTCC::Bounds* PointCloud::mutable_bounds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Bounds* _msg = _internal_mutable_bounds();
  // @@protoc_insertion_point(field_mutable:DTCC.PointCloud.bounds)
  return _msg;
}
inline void PointCloud::set_allocated_bounds(::DTCC::Bounds* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Bounds*>(_impl_.bounds_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Bounds*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.PointCloud.bounds)
}

// .DTCC.Transform transform = 7;
inline bool PointCloud::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void PointCloud::clear_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DTCC::Transform& PointCloud::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Transform&>(::DTCC::_Transform_default_instance_);
}
inline const ::DTCC::Transform& PointCloud::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.PointCloud.transform)
  return _internal_transform();
}
inline void PointCloud::unsafe_arena_set_allocated_transform(::DTCC::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.PointCloud.transform)
}
inline ::DTCC::Transform* PointCloud::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DTCC::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Transform* PointCloud::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.PointCloud.transform)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DTCC::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::DTCC::Transform* PointCloud::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::DTCC::Transform* PointCloud::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:DTCC.PointCloud.transform)
  return _msg;
}
inline void PointCloud::set_allocated_transform(::DTCC::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Transform*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Transform*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.transform_ = reinterpret_cast<::DTCC::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.PointCloud.transform)
}

// -------------------------------------------------------------------

// Grid

// .DTCC.Bounds bounds = 1;
inline bool Grid::has_bounds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bounds_ != nullptr);
  return value;
}
inline void Grid::clear_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bounds_ != nullptr) _impl_.bounds_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Bounds& Grid::_internal_bounds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Bounds* p = _impl_.bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Bounds&>(::DTCC::_Bounds_default_instance_);
}
inline const ::DTCC::Bounds& Grid::bounds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Grid.bounds)
  return _internal_bounds();
}
inline void Grid::unsafe_arena_set_allocated_bounds(::DTCC::Bounds* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bounds_);
  }
  _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.Grid.bounds)
}
inline ::DTCC::Bounds* Grid::release_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Bounds* released = _impl_.bounds_;
  _impl_.bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Bounds* Grid::unsafe_arena_release_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Grid.bounds)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Bounds* temp = _impl_.bounds_;
  _impl_.bounds_ = nullptr;
  return temp;
}
inline ::DTCC::Bounds* Grid::_internal_mutable_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Bounds>(GetArena());
    _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(p);
  }
  return _impl_.bounds_;
}
inline ::DTCC::Bounds* Grid::mutable_bounds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Bounds* _msg = _internal_mutable_bounds();
  // @@protoc_insertion_point(field_mutable:DTCC.Grid.bounds)
  return _msg;
}
inline void Grid::set_allocated_bounds(::DTCC::Bounds* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Bounds*>(_impl_.bounds_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Bounds*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.Grid.bounds)
}

// int32 width = 2;
inline void Grid::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline ::int32_t Grid::width() const {
  // @@protoc_insertion_point(field_get:DTCC.Grid.width)
  return _internal_width();
}
inline void Grid::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:DTCC.Grid.width)
}
inline ::int32_t Grid::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Grid::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// int32 height = 3;
inline void Grid::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline ::int32_t Grid::height() const {
  // @@protoc_insertion_point(field_get:DTCC.Grid.height)
  return _internal_height();
}
inline void Grid::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:DTCC.Grid.height)
}
inline ::int32_t Grid::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void Grid::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// VolumeGrid

// .DTCC.Bounds bounds = 1;
inline bool VolumeGrid::has_bounds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bounds_ != nullptr);
  return value;
}
inline void VolumeGrid::clear_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bounds_ != nullptr) _impl_.bounds_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DTCC::Bounds& VolumeGrid::_internal_bounds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DTCC::Bounds* p = _impl_.bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::DTCC::Bounds&>(::DTCC::_Bounds_default_instance_);
}
inline const ::DTCC::Bounds& VolumeGrid::bounds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.bounds)
  return _internal_bounds();
}
inline void VolumeGrid::unsafe_arena_set_allocated_bounds(::DTCC::Bounds* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bounds_);
  }
  _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DTCC.VolumeGrid.bounds)
}
inline ::DTCC::Bounds* VolumeGrid::release_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Bounds* released = _impl_.bounds_;
  _impl_.bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DTCC::Bounds* VolumeGrid::unsafe_arena_release_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.VolumeGrid.bounds)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DTCC::Bounds* temp = _impl_.bounds_;
  _impl_.bounds_ = nullptr;
  return temp;
}
inline ::DTCC::Bounds* VolumeGrid::_internal_mutable_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::DTCC::Bounds>(GetArena());
    _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(p);
  }
  return _impl_.bounds_;
}
inline ::DTCC::Bounds* VolumeGrid::mutable_bounds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DTCC::Bounds* _msg = _internal_mutable_bounds();
  // @@protoc_insertion_point(field_mutable:DTCC.VolumeGrid.bounds)
  return _msg;
}
inline void VolumeGrid::set_allocated_bounds(::DTCC::Bounds* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::DTCC::Bounds*>(_impl_.bounds_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::DTCC::Bounds*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bounds_ = reinterpret_cast<::DTCC::Bounds*>(value);
  // @@protoc_insertion_point(field_set_allocated:DTCC.VolumeGrid.bounds)
}

// int32 width = 2;
inline void VolumeGrid::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline ::int32_t VolumeGrid::width() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.width)
  return _internal_width();
}
inline void VolumeGrid::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.width)
}
inline ::int32_t VolumeGrid::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void VolumeGrid::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// int32 height = 3;
inline void VolumeGrid::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline ::int32_t VolumeGrid::height() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.height)
  return _internal_height();
}
inline void VolumeGrid::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.height)
}
inline ::int32_t VolumeGrid::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void VolumeGrid::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.height_ = value;
}

// int32 depth = 4;
inline void VolumeGrid::clear_depth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.depth_ = 0;
}
inline ::int32_t VolumeGrid::depth() const {
  // @@protoc_insertion_point(field_get:DTCC.VolumeGrid.depth)
  return _internal_depth();
}
inline void VolumeGrid::set_depth(::int32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:DTCC.VolumeGrid.depth)
}
inline ::int32_t VolumeGrid::_internal_depth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.depth_;
}
inline void VolumeGrid::_internal_set_depth(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.depth_ = value;
}

// -------------------------------------------------------------------

// Raster

// repeated float data = 1;
inline int Raster::_internal_data_size() const {
  return _internal_data().size();
}
inline int Raster::data_size() const {
  return _internal_data_size();
}
inline void Raster::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline float Raster::data(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.data)
  return _internal_data().Get(index);
}
inline void Raster::set_data(int index, float value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Raster.data)
}
inline void Raster::add_data(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.Raster.data)
}
inline const ::google::protobuf::RepeatedField<float>& Raster::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Raster.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<float>* Raster::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Raster.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<float>& Raster::_internal_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<float>* Raster::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// uint32 heigh = 2;
inline void Raster::clear_heigh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heigh_ = 0u;
}
inline ::uint32_t Raster::heigh() const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.heigh)
  return _internal_heigh();
}
inline void Raster::set_heigh(::uint32_t value) {
  _internal_set_heigh(value);
  // @@protoc_insertion_point(field_set:DTCC.Raster.heigh)
}
inline ::uint32_t Raster::_internal_heigh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heigh_;
}
inline void Raster::_internal_set_heigh(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heigh_ = value;
}

// uint32 width = 3;
inline void Raster::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0u;
}
inline ::uint32_t Raster::width() const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.width)
  return _internal_width();
}
inline void Raster::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:DTCC.Raster.width)
}
inline ::uint32_t Raster::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Raster::_internal_set_width(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// uint32 dims = 4;
inline void Raster::clear_dims() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dims_ = 0u;
}
inline ::uint32_t Raster::dims() const {
  // @@protoc_insertion_point(field_get:DTCC.Raster.dims)
  return _internal_dims();
}
inline void Raster::set_dims(::uint32_t value) {
  _internal_set_dims(value);
  // @@protoc_insertion_point(field_set:DTCC.Raster.dims)
}
inline ::uint32_t Raster::_internal_dims() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dims_;
}
inline void Raster::_internal_set_dims(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dims_ = value;
}

// -------------------------------------------------------------------

// Transform

// string srs = 1;
inline void Transform::clear_srs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.srs_.ClearToEmpty();
}
inline const std::string& Transform::srs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DTCC.Transform.srs)
  return _internal_srs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Transform::set_srs(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.srs_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DTCC.Transform.srs)
}
inline std::string* Transform::mutable_srs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_srs();
  // @@protoc_insertion_point(field_mutable:DTCC.Transform.srs)
  return _s;
}
inline const std::string& Transform::_internal_srs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.srs_.Get();
}
inline void Transform::_internal_set_srs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.srs_.Set(value, GetArena());
}
inline std::string* Transform::_internal_mutable_srs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.srs_.Mutable( GetArena());
}
inline std::string* Transform::release_srs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DTCC.Transform.srs)
  return _impl_.srs_.Release();
}
inline void Transform::set_allocated_srs(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.srs_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.srs_.IsDefault()) {
          _impl_.srs_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DTCC.Transform.srs)
}

// repeated float affine = 2;
inline int Transform::_internal_affine_size() const {
  return _internal_affine().size();
}
inline int Transform::affine_size() const {
  return _internal_affine_size();
}
inline void Transform::clear_affine() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.affine_.Clear();
}
inline float Transform::affine(int index) const {
  // @@protoc_insertion_point(field_get:DTCC.Transform.affine)
  return _internal_affine().Get(index);
}
inline void Transform::set_affine(int index, float value) {
  _internal_mutable_affine()->Set(index, value);
  // @@protoc_insertion_point(field_set:DTCC.Transform.affine)
}
inline void Transform::add_affine(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_affine()->Add(value);
  // @@protoc_insertion_point(field_add:DTCC.Transform.affine)
}
inline const ::google::protobuf::RepeatedField<float>& Transform::affine() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DTCC.Transform.affine)
  return _internal_affine();
}
inline ::google::protobuf::RepeatedField<float>* Transform::mutable_affine()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DTCC.Transform.affine)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_affine();
}
inline const ::google::protobuf::RepeatedField<float>& Transform::_internal_affine()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.affine_;
}
inline ::google::protobuf::RepeatedField<float>* Transform::_internal_mutable_affine() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.affine_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace DTCC


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_dtcc_2eproto_2epb_2eh
